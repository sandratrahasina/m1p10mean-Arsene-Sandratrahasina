import {
  NzToolTipModule,
  NzTooltipDirective
} from "./chunk-G5E3ZBBD.js";
import "./chunk-3ZTF6XOF.js";
import "./chunk-CI5DGOKL.js";
import "./chunk-NTY5IID6.js";
import {
  ResponsiveService
} from "./chunk-KGHF7NNJ.js";
import "./chunk-FSEFCYMU.js";
import "./chunk-YI23FGK5.js";
import "./chunk-2X2DHHBW.js";
import "./chunk-XRNNFB2N.js";
import {
  CdkObserveContent,
  ObserversModule
} from "./chunk-IPKUYFYL.js";
import "./chunk-Y4W7AVST.js";
import "./chunk-7A7F2ESV.js";
import "./chunk-Z4GMGEHN.js";
import "./chunk-3Z4XHAHP.js";
import "./chunk-XF22SSGY.js";
import "./chunk-AH32UZUP.js";
import "./chunk-UYYIOVNB.js";
import "./chunk-27BDGVS6.js";
import "./chunk-A532CSVY.js";
import {
  NzOutletModule,
  NzStringTemplateOutletDirective
} from "./chunk-Z2ZVAQCX.js";
import {
  NzIconDirective,
  NzIconModule
} from "./chunk-3MXKVZO7.js";
import "./chunk-5QBFNWJX.js";
import "./chunk-6WPOZNJ5.js";
import "./chunk-YORGFY4X.js";
import "./chunk-DSM4JBCF.js";
import "./chunk-YWFK6PYB.js";
import {
  isEmpty
} from "./chunk-75EB2NOQ.js";
import {
  AlainConfigService
} from "./chunk-Q3BVRUJT.js";
import "./chunk-B7EG4KFO.js";
import "./chunk-NX2IJXEA.js";
import "./chunk-KN3RWPAL.js";
import "./chunk-TQFAWZD6.js";
import "./chunk-BPMU3QPJ.js";
import "./chunk-TECWR7MN.js";
import {
  CommonModule,
  NgStyle
} from "./chunk-WL36VPKJ.js";
import {
  ChangeDetectionStrategy,
  Component,
  ElementRef,
  Input,
  InputFlags,
  NgModule,
  Renderer2,
  ViewChild,
  ViewEncapsulation$1,
  booleanAttribute,
  inject,
  numberAttribute,
  setClassMetadata,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵdefineComponent,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵqueryRefresh,
  ɵɵsanitizeHtml,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵviewQuery
} from "./chunk-T4EVUEAM.js";
import "./chunk-JKR55PDT.js";
import "./chunk-ASLTLD6L.js";

// node_modules/@delon/abc/fesm2022/sv.mjs
var _c0 = ["*"];
function SVContainerComponent_Conditional_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.title);
  }
}
function SVContainerComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "sv-title");
    ɵɵtemplate(1, SVContainerComponent_Conditional_1_ng_container_1_Template, 2, 1, "ng-container", 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("nzStringTemplateOutlet", ctx_r0.title);
  }
}
function SVValueComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "em", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r0.prefix, ɵɵsanitizeHtml);
  }
}
function SVValueComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "em", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r1.unit, ɵɵsanitizeHtml);
  }
}
var _c1 = ["conEl"];
function SVComponent_Conditional_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.label);
  }
}
function SVComponent_Conditional_0_Conditional_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r5.optional);
  }
}
function SVComponent_Conditional_0_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "i", 10);
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(3);
    ɵɵproperty("nzTooltipTitle", ctx_r6.optionalHelp)("nzTooltipColor", ctx_r6.optionalHelpColor);
  }
}
function SVComponent_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtemplate(1, SVComponent_Conditional_0_Conditional_3_ng_container_1_Template, 2, 1, "ng-container", 7)(2, SVComponent_Conditional_0_Conditional_3_Conditional_2_Template, 1, 2, "i", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵclassProp("sv__label-optional-no-text", !ctx_r4.optional);
    ɵɵadvance();
    ɵɵproperty("nzStringTemplateOutlet", ctx_r4.optional);
    ɵɵadvance();
    ɵɵconditional(2, ctx_r4.optionalHelp ? 2 : -1);
  }
}
function SVComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5)(1, "span", 6);
    ɵɵtemplate(2, SVComponent_Conditional_0_ng_container_2_Template, 2, 1, "ng-container", 7);
    ɵɵelementEnd();
    ɵɵtemplate(3, SVComponent_Conditional_0_Conditional_3_Template, 3, 4, "span", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r0.labelWidth, "px");
    ɵɵclassProp("sv__label-empty", !ctx_r0.label)("sv__label-width", ctx_r0.labelWidth !== null && ctx_r0.labelWidth !== void 0)("sv__no-colon", ctx_r0._noColon);
    ɵɵadvance(2);
    ɵɵproperty("nzStringTemplateOutlet", ctx_r0.label);
    ɵɵadvance();
    ɵɵconditional(3, ctx_r0.optional || ctx_r0.optionalHelp ? 3 : -1);
  }
}
function SVComponent_Conditional_5_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r7.unit);
  }
}
function SVComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SVComponent_Conditional_5_span_0_Template, 2, 1, "span", 11);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("nzStringTemplateOutlet", ctx_r2.unit);
  }
}
var _SVTitleComponent = class _SVTitleComponent {
  constructor() {
    this.el = inject(ElementRef).nativeElement;
    this.parentComp = inject(SVContainerComponent, {
      host: true,
      optional: true
    });
    this.ren = inject(Renderer2);
    if (this.parentComp == null) {
      throw new Error(`[sv-title] must include 'sv-container' component`);
    }
  }
  setClass() {
    const gutter = this.parentComp.gutter;
    const el = this.el;
    this.ren.setStyle(el, "padding-left", `${gutter / 2}px`);
    this.ren.setStyle(el, "padding-right", `${gutter / 2}px`);
  }
  ngOnInit() {
    this.setClass();
  }
};
_SVTitleComponent.ɵfac = function SVTitleComponent_Factory(t) {
  return new (t || _SVTitleComponent)();
};
_SVTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: _SVTitleComponent,
  selectors: [["sv-title"], ["", "sv-title", ""]],
  hostVars: 2,
  hostBindings: function SVTitleComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("sv__title", true);
    }
  },
  exportAs: ["svTitle"],
  standalone: true,
  features: [ɵɵStandaloneFeature],
  ngContentSelectors: _c0,
  decls: 1,
  vars: 0,
  template: function SVTitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var SVTitleComponent = _SVTitleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVTitleComponent, [{
    type: Component,
    args: [{
      selector: "sv-title, [sv-title]",
      exportAs: "svTitle",
      template: "<ng-content />",
      host: {
        "[class.sv__title]": "true"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true
    }]
  }], () => [], null);
})();
var _SVContainerComponent = class _SVContainerComponent {
  get margin() {
    return this.bordered ? {} : {
      "margin-left.px": -(this.gutter / 2),
      "margin-right.px": -(this.gutter / 2)
    };
  }
  constructor(configSrv) {
    this.noColon = false;
    this.bordered = false;
    configSrv.attach(this, "sv", {
      size: "large",
      gutter: 32,
      layout: "horizontal",
      col: 3,
      default: true
    });
  }
};
_SVContainerComponent.ɵfac = function SVContainerComponent_Factory(t) {
  return new (t || _SVContainerComponent)(ɵɵdirectiveInject(AlainConfigService));
};
_SVContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _SVContainerComponent,
  selectors: [["sv-container"], ["", "sv-container", ""]],
  hostVars: 14,
  hostBindings: function SVContainerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("sv__container", true)("sv__horizontal", ctx.layout === "horizontal")("sv__vertical", ctx.layout === "vertical")("sv__small", ctx.size === "small")("sv__large", ctx.size === "large")("sv__bordered", ctx.bordered)("clearfix", true);
    }
  },
  inputs: {
    colInCon: [InputFlags.HasDecoratorInputTransform, "sv-container", "colInCon", (v) => v == null ? null : numberAttribute(v)],
    title: "title",
    size: "size",
    gutter: [InputFlags.HasDecoratorInputTransform, "gutter", "gutter", numberAttribute],
    layout: "layout",
    labelWidth: [InputFlags.HasDecoratorInputTransform, "labelWidth", "labelWidth", numberAttribute],
    col: [InputFlags.HasDecoratorInputTransform, "col", "col", numberAttribute],
    default: [InputFlags.HasDecoratorInputTransform, "default", "default", booleanAttribute],
    noColon: [InputFlags.HasDecoratorInputTransform, "noColon", "noColon", booleanAttribute],
    bordered: [InputFlags.HasDecoratorInputTransform, "bordered", "bordered", booleanAttribute]
  },
  exportAs: ["svContainer"],
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵStandaloneFeature],
  ngContentSelectors: _c0,
  decls: 3,
  vars: 2,
  consts: [[1, "ant-row", 3, "ngStyle"], [4, "nzStringTemplateOutlet"]],
  template: function SVContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, SVContainerComponent_Conditional_1_Template, 2, 1, "sv-title");
      ɵɵprojection(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngStyle", ctx.margin);
      ɵɵadvance();
      ɵɵconditional(1, ctx.title ? 1 : -1);
    }
  },
  dependencies: [NgStyle, SVTitleComponent, NzStringTemplateOutletDirective],
  encapsulation: 2,
  changeDetection: 0
});
var SVContainerComponent = _SVContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVContainerComponent, [{
    type: Component,
    args: [{
      selector: "sv-container, [sv-container]",
      exportAs: "svContainer",
      template: `
    <div class="ant-row" [ngStyle]="margin">
      @if (title) {
        <sv-title>
          <ng-container *nzStringTemplateOutlet="title">{{ title }}</ng-container>
        </sv-title>
      }
      <ng-content />
    </div>
  `,
      host: {
        "[class.sv__container]": "true",
        "[class.sv__horizontal]": `layout === 'horizontal'`,
        "[class.sv__vertical]": `layout === 'vertical'`,
        "[class.sv__small]": `size === 'small'`,
        "[class.sv__large]": `size === 'large'`,
        "[class.sv__bordered]": `bordered`,
        "[class.clearfix]": `true`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [NgStyle, SVTitleComponent, NzStringTemplateOutletDirective]
    }]
  }], () => [{
    type: AlainConfigService
  }], {
    colInCon: [{
      type: Input,
      args: [{
        alias: "sv-container",
        transform: (v) => v == null ? null : numberAttribute(v)
      }]
    }],
    title: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    gutter: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    layout: [{
      type: Input
    }],
    labelWidth: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    col: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    default: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    noColon: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    bordered: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var _SVValueComponent = class _SVValueComponent {
  constructor() {
    this.size = "default";
  }
};
_SVValueComponent.ɵfac = function SVValueComponent_Factory(t) {
  return new (t || _SVValueComponent)();
};
_SVValueComponent.ɵcmp = ɵɵdefineComponent({
  type: _SVValueComponent,
  selectors: [["sv-value"], ["", "sv-value", ""]],
  hostVars: 6,
  hostBindings: function SVValueComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("sv__value", true)("sv__value-small", ctx.size === "small")("sv__value-large", ctx.size === "large");
    }
  },
  inputs: {
    prefix: "prefix",
    unit: "unit",
    tooltip: "tooltip",
    size: "size"
  },
  exportAs: ["svValue"],
  standalone: true,
  features: [ɵɵStandaloneFeature],
  ngContentSelectors: _c0,
  decls: 4,
  vars: 3,
  consts: [["class", "sv__value-prefix", 3, "innerHTML"], ["nz-tooltip", "", 1, "sv__value-text", 3, "nzTooltipTitle"], ["class", "sv__value-unit", 3, "innerHTML"], [1, "sv__value-prefix", 3, "innerHTML"], [1, "sv__value-unit", 3, "innerHTML"]],
  template: function SVValueComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, SVValueComponent_Conditional_0_Template, 1, 1, "em", 0);
      ɵɵelementStart(1, "span", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, SVValueComponent_Conditional_3_Template, 1, 1, "em", 2);
    }
    if (rf & 2) {
      ɵɵconditional(0, ctx.prefix ? 0 : -1);
      ɵɵadvance();
      ɵɵproperty("nzTooltipTitle", ctx.tooltip);
      ɵɵadvance(2);
      ɵɵconditional(3, ctx.unit ? 3 : -1);
    }
  },
  dependencies: [NzTooltipDirective],
  encapsulation: 2,
  changeDetection: 0
});
var SVValueComponent = _SVValueComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVValueComponent, [{
    type: Component,
    args: [{
      selector: "sv-value, [sv-value]",
      exportAs: "svValue",
      template: `
    @if (prefix) {
      <em class="sv__value-prefix" [innerHTML]="prefix"></em>
    }
    <span nz-tooltip [nzTooltipTitle]="tooltip" class="sv__value-text"><ng-content /></span>
    @if (unit) {
      <em class="sv__value-unit" [innerHTML]="unit"></em>
    }
  `,
      host: {
        "[class.sv__value]": "true",
        "[class.sv__value-small]": `size === 'small'`,
        "[class.sv__value-large]": `size === 'large'`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [NzTooltipDirective]
    }]
  }], null, {
    prefix: [{
      type: Input
    }],
    unit: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }],
    size: [{
      type: Input
    }]
  });
})();
var prefixCls = `sv`;
var _SVComponent = class _SVComponent {
  // #endregion
  get paddingValue() {
    if (this.parentComp.bordered)
      return null;
    return this.parentComp.gutter / 2;
  }
  get labelWidth() {
    const {
      labelWidth,
      layout
    } = this.parentComp;
    return layout === "horizontal" ? labelWidth : null;
  }
  constructor() {
    this.el = inject(ElementRef).nativeElement;
    this.parentComp = inject(SVContainerComponent, {
      host: true,
      optional: true
    });
    this.rep = inject(ResponsiveService);
    this.ren = inject(Renderer2);
    this.clsMap = [];
    this._noColon = false;
    this.hideLabel = false;
    if (this.parentComp == null) {
      throw new Error(`[sv] must include 'sv-container' component`);
    }
  }
  setClass() {
    const {
      ren,
      col,
      clsMap,
      type,
      rep,
      noColon
    } = this;
    const parent = this.parentComp;
    const el = this.el;
    this._noColon = parent.bordered ? true : noColon != null ? noColon : parent.noColon;
    clsMap.forEach((cls) => ren.removeClass(el, cls));
    clsMap.length = 0;
    const parentCol = parent.colInCon || parent.col;
    clsMap.push(...rep.genCls(col != null ? col : parentCol, parentCol));
    clsMap.push(`${prefixCls}__item`);
    if (parent.labelWidth)
      clsMap.push(`${prefixCls}__item-fixed`);
    if (type)
      clsMap.push(`${prefixCls}__type-${type}`);
    clsMap.forEach((cls) => ren.addClass(el, cls));
  }
  ngAfterViewInit() {
    this.setClass();
    this.checkContent();
  }
  ngOnChanges() {
    this.setClass();
  }
  checkContent() {
    const {
      conEl
    } = this;
    const def = this.default;
    if (!(def != null ? def : this.parentComp?.default)) {
      return;
    }
    const el = conEl.nativeElement;
    const cls = `sv__default`;
    if (el.classList.contains(cls)) {
      el.classList.remove(cls);
    }
    if (isEmpty(el)) {
      el.classList.add(cls);
    }
  }
};
_SVComponent.ɵfac = function SVComponent_Factory(t) {
  return new (t || _SVComponent)();
};
_SVComponent.ɵcmp = ɵɵdefineComponent({
  type: _SVComponent,
  selectors: [["sv"], ["", "sv", ""]],
  viewQuery: function SVComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c1, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.conEl = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function SVComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("padding-left", ctx.paddingValue, "px")("padding-right", ctx.paddingValue, "px");
    }
  },
  inputs: {
    optional: "optional",
    optionalHelp: "optionalHelp",
    optionalHelpColor: "optionalHelpColor",
    label: "label",
    unit: "unit",
    col: [InputFlags.HasDecoratorInputTransform, "col", "col", (v) => v == null ? null : numberAttribute(v)],
    default: [InputFlags.HasDecoratorInputTransform, "default", "default", (v) => v == null ? null : booleanAttribute(v)],
    type: "type",
    noColon: [InputFlags.HasDecoratorInputTransform, "noColon", "noColon", (v) => v == null ? null : booleanAttribute(v)],
    hideLabel: [InputFlags.HasDecoratorInputTransform, "hideLabel", "hideLabel", booleanAttribute]
  },
  exportAs: ["sv"],
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
  ngContentSelectors: _c0,
  decls: 6,
  vars: 2,
  consts: [["class", "sv__label", 3, "sv__label-empty", "sv__label-width", "sv__no-colon", "width"], [1, "sv__detail"], [3, "cdkObserveContent"], ["conEl", ""], ["class", "sv__unit"], [1, "sv__label"], [1, "sv__label-text"], [4, "nzStringTemplateOutlet"], ["class", "sv__label-optional", 3, "sv__label-optional-no-text"], [1, "sv__label-optional"], ["nz-tooltip", "", "nz-icon", "", "nzType", "question-circle", 3, "nzTooltipTitle", "nzTooltipColor"], ["class", "sv__unit", 4, "nzStringTemplateOutlet"], [1, "sv__unit"]],
  template: function SVComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, SVComponent_Conditional_0_Template, 4, 10, "div", 0);
      ɵɵelementStart(1, "div", 1)(2, "span", 2, 3);
      ɵɵlistener("cdkObserveContent", function SVComponent_Template_span_cdkObserveContent_2_listener() {
        return ctx.checkContent();
      });
      ɵɵprojection(4);
      ɵɵelementEnd();
      ɵɵtemplate(5, SVComponent_Conditional_5_Template, 1, 1, "span", 4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵconditional(0, !ctx.hideLabel ? 0 : -1);
      ɵɵadvance(5);
      ɵɵconditional(5, !!ctx.unit ? 5 : -1);
    }
  },
  dependencies: [NzStringTemplateOutletDirective, NzTooltipDirective, NzIconDirective, CdkObserveContent],
  encapsulation: 2,
  changeDetection: 0
});
var SVComponent = _SVComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVComponent, [{
    type: Component,
    args: [{
      selector: "sv, [sv]",
      exportAs: "sv",
      host: {
        "[style.padding-left.px]": "paddingValue",
        "[style.padding-right.px]": "paddingValue"
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [NzStringTemplateOutletDirective, NzTooltipDirective, NzIconDirective, CdkObserveContent],
      template: '@if (!hideLabel) {\n  <div\n    class="sv__label"\n    [class.sv__label-empty]="!label"\n    [class.sv__label-width]="labelWidth !== null && labelWidth !== undefined"\n    [class.sv__no-colon]="_noColon"\n    [style.width.px]="labelWidth"\n  >\n    <span class="sv__label-text">\n      <ng-container *nzStringTemplateOutlet="label">{{ label }}</ng-container>\n    </span>\n    @if (optional || optionalHelp) {\n      <span class="sv__label-optional" [class.sv__label-optional-no-text]="!optional">\n        <ng-container *nzStringTemplateOutlet="optional">{{ optional }}</ng-container>\n        @if (optionalHelp) {\n          <i\n            nz-tooltip\n            [nzTooltipTitle]="optionalHelp"\n            [nzTooltipColor]="optionalHelpColor"\n            nz-icon\n            nzType="question-circle"\n          ></i>\n        }\n      </span>\n    }\n  </div>\n}\n<div class="sv__detail">\n  <span (cdkObserveContent)="checkContent()" #conEl>\n    <ng-content />\n  </span>\n  @if (!!unit) {\n    <span class="sv__unit" *nzStringTemplateOutlet="unit">{{ unit }}</span>\n  }\n</div>\n'
    }]
  }], () => [], {
    conEl: [{
      type: ViewChild,
      args: ["conEl", {
        static: false
      }]
    }],
    optional: [{
      type: Input
    }],
    optionalHelp: [{
      type: Input
    }],
    optionalHelpColor: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    unit: [{
      type: Input
    }],
    col: [{
      type: Input,
      args: [{
        transform: (v) => v == null ? null : numberAttribute(v)
      }]
    }],
    default: [{
      type: Input,
      args: [{
        transform: (v) => v == null ? null : booleanAttribute(v)
      }]
    }],
    type: [{
      type: Input
    }],
    noColon: [{
      type: Input,
      args: [{
        transform: (v) => v == null ? null : booleanAttribute(v)
      }]
    }],
    hideLabel: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var COMPONENTS = [SVContainerComponent, SVComponent, SVTitleComponent, SVValueComponent];
var _SVModule = class _SVModule {
};
_SVModule.ɵfac = function SVModule_Factory(t) {
  return new (t || _SVModule)();
};
_SVModule.ɵmod = ɵɵdefineNgModule({
  type: _SVModule,
  imports: [CommonModule, ObserversModule, NzToolTipModule, NzIconModule, NzOutletModule, SVContainerComponent, SVComponent, SVTitleComponent, SVValueComponent],
  exports: [SVContainerComponent, SVComponent, SVTitleComponent, SVValueComponent]
});
_SVModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ObserversModule, NzToolTipModule, NzIconModule, NzOutletModule]
});
var SVModule = _SVModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SVModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ObserversModule, NzToolTipModule, NzIconModule, NzOutletModule, ...COMPONENTS],
      exports: COMPONENTS
    }]
  }], null, null);
})();
export {
  SVComponent,
  SVContainerComponent,
  SVModule,
  SVTitleComponent,
  SVValueComponent
};
//# sourceMappingURL=@delon_abc_sv.js.map
