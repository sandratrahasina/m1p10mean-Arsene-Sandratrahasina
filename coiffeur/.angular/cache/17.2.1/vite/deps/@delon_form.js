import {
  NzFormDirective,
  NzFormItemComponent,
  NzFormModule
} from "./chunk-C3IP4IS5.js";
import {
  NzColDirective,
  NzGridModule,
  NzRowDirective
} from "./chunk-N6OHL5LA.js";
import {
  NzSwitchComponent,
  NzSwitchModule
} from "./chunk-LFIK6KM6.js";
import {
  NzCardComponent,
  NzCardModule
} from "./chunk-FJY4XI6G.js";
import {
  NzDatePickerComponent,
  NzDatePickerModule,
  NzMonthPickerComponent,
  NzRangePickerComponent,
  NzWeekPickerComponent,
  NzYearPickerComponent
} from "./chunk-RFPPEW2N.js";
import {
  NzOptionComponent,
  NzOptionGroupComponent,
  NzSelectComponent,
  NzSelectModule
} from "./chunk-XXGFXZTF.js";
import {
  NzInputNumberComponent,
  NzInputNumberModule
} from "./chunk-BAMIZHC5.js";
import {
  NzAutosizeDirective,
  NzInputDirective,
  NzInputGroupComponent,
  NzInputGroupWhitSuffixOrPrefixDirective,
  NzInputModule,
  NzTextareaCountComponent
} from "./chunk-OLWLQNMO.js";
import {
  NzRadioButtonDirective,
  NzRadioComponent,
  NzRadioGroupComponent,
  NzRadioModule
} from "./chunk-HXOUKI53.js";
import {
  NzCheckboxComponent,
  NzCheckboxGroupComponent,
  NzCheckboxModule,
  NzCheckboxWrapperComponent
} from "./chunk-DHBECBBO.js";
import {
  REGEX
} from "./chunk-H2P56GNF.js";
import "./chunk-L2FU2BSY.js";
import {
  NzFormStatusService
} from "./chunk-CZ6RLQOU.js";
import {
  NzToolTipModule,
  NzTooltipDirective
} from "./chunk-G5E3ZBBD.js";
import "./chunk-3ZTF6XOF.js";
import "./chunk-CI5DGOKL.js";
import {
  helpMotion
} from "./chunk-NTY5IID6.js";
import {
  DefaultValueAccessor,
  FormsModule,
  NgControlStatus,
  NgControlStatusGroup,
  NgForm,
  NgModel,
  ɵNgNoValidate
} from "./chunk-FLHT77OR.js";
import {
  ALAIN_I18N_TOKEN,
  DelonLocaleModule,
  DelonLocaleService,
  toDate
} from "./chunk-KGHF7NNJ.js";
import {
  NzModalModule
} from "./chunk-FSEFCYMU.js";
import "./chunk-YI23FGK5.js";
import "./chunk-2X2DHHBW.js";
import {
  format
} from "./chunk-XRNNFB2N.js";
import "./chunk-IPKUYFYL.js";
import {
  ACLService
} from "./chunk-Y4W7AVST.js";
import "./chunk-7A7F2ESV.js";
import "./chunk-Z4GMGEHN.js";
import "./chunk-3Z4XHAHP.js";
import {
  NzButtonComponent,
  NzButtonModule
} from "./chunk-XF22SSGY.js";
import {
  NzWaveDirective
} from "./chunk-AH32UZUP.js";
import {
  NzTransitionPatchDirective
} from "./chunk-UYYIOVNB.js";
import "./chunk-27BDGVS6.js";
import "./chunk-A532CSVY.js";
import "./chunk-Z2ZVAQCX.js";
import {
  NzIconDirective,
  NzIconModule
} from "./chunk-3MXKVZO7.js";
import "./chunk-5QBFNWJX.js";
import "./chunk-6WPOZNJ5.js";
import "./chunk-YORGFY4X.js";
import "./chunk-DSM4JBCF.js";
import {
  takeUntilDestroyed
} from "./chunk-YWFK6PYB.js";
import {
  AlainConfigService,
  deepCopy
} from "./chunk-Q3BVRUJT.js";
import {
  Platform
} from "./chunk-B7EG4KFO.js";
import "./chunk-NX2IJXEA.js";
import "./chunk-KN3RWPAL.js";
import "./chunk-TQFAWZD6.js";
import {
  DomSanitizer
} from "./chunk-BPMU3QPJ.js";
import "./chunk-TECWR7MN.js";
import {
  CommonModule,
  NgClass,
  NgForOf,
  NgTemplateOutlet
} from "./chunk-WL36VPKJ.js";
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  Directive,
  ENVIRONMENT_INITIALIZER,
  ElementRef,
  EventEmitter,
  HostBinding,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InputFlags,
  NgModule,
  NgZone,
  Output,
  Renderer2,
  TemplateRef,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation$1,
  booleanAttribute,
  inject,
  makeEnvironmentProviders,
  numberAttribute,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction3,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-T4EVUEAM.js";
import {
  BehaviorSubject,
  Observable,
  Subject,
  catchError,
  combineLatest,
  debounceTime,
  distinctUntilChanged,
  filter,
  map,
  merge,
  of,
  switchMap,
  take,
  takeUntil
} from "./chunk-JKR55PDT.js";
import {
  __async,
  __commonJS,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-ASLTLD6L.js";

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? line : code_1.nil });
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : __spreadValues({}, this.lhs.names);
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? "\n" : "" });
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : __spreadValues(__spreadValues({}, from), to),
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type = exports.Type || (exports.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      errors: new codegen_1.Name("errors"),
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: __spreadProps(__spreadValues({}, groups), { integer: true, boolean: true, null: true }),
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType = exports.DataType || (exports.DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData2(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema), { items: void 0, props: void 0 });
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData2($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData2;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "node_modules/uri-js/dist/es5/uri.all.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.URI = global.URI || {});
    })(exports, function(exports2) {
      "use strict";
      function merge2() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map2(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve;
      exports2.normalize = normalize;
      exports2.equal = equal;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? __spreadProps(__spreadValues({}, o.code), { optimize, regExp }) : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = __spreadValues(__spreadValues({}, opts), requiredOptions(opts));
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = __spreadValues({}, $dataRefSchema);
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        function runCompileAsync(_schema, _meta) {
          return __async(this, null, function* () {
            yield loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          });
        }
        function loadMetaSchema($ref) {
          return __async(this, null, function* () {
            if ($ref && !this.getSchema($ref)) {
              yield runCompileAsync.call(this, { $ref }, true);
            }
          });
        }
        function _compileAsync(sch) {
          return __async(this, null, function* () {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e) {
              if (!(e instanceof ref_error_1.default))
                throw e;
              checkLoaded.call(this, e);
              yield loadMissingSchema.call(this, e.missingSchema);
              return _compileAsync.call(this, sch);
            }
          });
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        function loadMissingSchema(ref) {
          return __async(this, null, function* () {
            const _schema = yield _loadSchema.call(this, ref);
            if (!this.refs[ref])
              yield loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
              this.addSchema(_schema, ref, meta);
          });
        }
        function _loadSchema(ref) {
          return __async(this, null, function* () {
            const p = this._loading[ref];
            if (p)
              return p;
            try {
              return yield this._loading[ref] = loadSchema(ref);
            } finally {
              delete this._loading[ref];
            }
          });
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = __spreadProps(__spreadValues({}, def), {
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        });
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name] = format2;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    exports.default = Ajv2;
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format2 = this.opts.formats[name];
        if (format2)
          this.addFormat(name, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = __spreadValues({}, this.opts);
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: __spreadProps(__spreadValues({}, definition), {
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        })
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format2 = [format_1.default];
    exports.default = format2;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    module.exports = exports = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(time, compareTime),
      "date-time": fmtDef(date_time, compareDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports.fastFormats = __spreadProps(__spreadValues({}, exports.fullFormats), {
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    });
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function time(str, withTimeZone) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hour = +matches[1];
      const minute = +matches[2];
      const second = +matches[3];
      const timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
    }
    function compareTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
      t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format2 = fCxt.schema;
          const fmtDef = self.formats[format2];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format2}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format2,
            ref: fmtDef,
            code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format2)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports.formatLimitDefinition);
      return ajv;
    };
    exports.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats2(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats2(ajv, list, formats, exportName);
      if (opts.keywords)
        limit_1.default(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats2(ajv, list, fs, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  }
});

// node_modules/@delon/form/fesm2022/form.mjs
var import_ajv = __toESM(require_ajv(), 1);
var import_ajv_formats = __toESM(require_dist(), 1);

// node_modules/ng-zorro-antd/fesm2022/ng-zorro-antd-core-tree.mjs
var NzTreeNode = class _NzTreeNode {
  get treeService() {
    return this.service || this.parentNode && this.parentNode.treeService;
  }
  /**
   * Init nzTreeNode
   *
   * @param option: user's input
   * @param parent
   * @param service: base nzTreeService
   */
  constructor(option, parent = null, service = null) {
    this._title = "";
    this.level = 0;
    this.parentNode = null;
    this._icon = "";
    this._children = [];
    this._isLeaf = false;
    this._isChecked = false;
    this._isSelectable = false;
    this._isDisabled = false;
    this._isDisableCheckbox = false;
    this._isExpanded = false;
    this._isHalfChecked = false;
    this._isSelected = false;
    this._isLoading = false;
    this.canHide = false;
    this.isMatched = false;
    this.service = null;
    if (option instanceof _NzTreeNode) {
      return option;
    }
    this.service = service || null;
    this.origin = option;
    this.key = option.key;
    this.parentNode = parent;
    this._title = option.title || "---";
    this._icon = option.icon || "";
    this._isLeaf = option.isLeaf || false;
    this._children = [];
    this._isChecked = option.checked || false;
    this._isSelectable = option.disabled || option.selectable !== false;
    this._isDisabled = option.disabled || false;
    this._isDisableCheckbox = option.disableCheckbox || false;
    this._isExpanded = option.isLeaf ? false : option.expanded || false;
    this._isHalfChecked = false;
    this._isSelected = !option.disabled && option.selected || false;
    this._isLoading = false;
    this.isMatched = false;
    if (parent) {
      this.level = parent.level + 1;
    } else {
      this.level = 0;
    }
    if (typeof option.children !== "undefined" && option.children !== null) {
      option.children.forEach((nodeOptions) => {
        const s = this.treeService;
        if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {
          nodeOptions.checked = option.checked;
        }
        this._children.push(new _NzTreeNode(nodeOptions, this));
      });
    }
  }
  /**
   * auto generate
   * get
   * set
   */
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this.update();
  }
  get icon() {
    return this._icon;
  }
  set icon(value) {
    this._icon = value;
    this.update();
  }
  get children() {
    return this._children;
  }
  set children(value) {
    this._children = value;
    this.update();
  }
  get isLeaf() {
    return this._isLeaf;
  }
  set isLeaf(value) {
    this._isLeaf = value;
    this.update();
  }
  get isChecked() {
    return this._isChecked;
  }
  set isChecked(value) {
    this._isChecked = value;
    this.origin.checked = value;
    this.afterValueChange("isChecked");
  }
  get isHalfChecked() {
    return this._isHalfChecked;
  }
  set isHalfChecked(value) {
    this._isHalfChecked = value;
    this.afterValueChange("isHalfChecked");
  }
  get isSelectable() {
    return this._isSelectable;
  }
  set isSelectable(value) {
    this._isSelectable = value;
    this.update();
  }
  get isDisabled() {
    return this._isDisabled;
  }
  set isDisabled(value) {
    this._isDisabled = value;
    this.update();
  }
  get isDisableCheckbox() {
    return this._isDisableCheckbox;
  }
  set isDisableCheckbox(value) {
    this._isDisableCheckbox = value;
    this.update();
  }
  get isExpanded() {
    return this._isExpanded;
  }
  set isExpanded(value) {
    this._isExpanded = value;
    this.origin.expanded = value;
    this.afterValueChange("isExpanded");
    this.afterValueChange("reRender");
  }
  get isSelected() {
    return this._isSelected;
  }
  set isSelected(value) {
    this._isSelected = value;
    this.origin.selected = value;
    this.afterValueChange("isSelected");
  }
  get isLoading() {
    return this._isLoading;
  }
  set isLoading(value) {
    this._isLoading = value;
    this.update();
  }
  setSyncChecked(checked = false, halfChecked = false) {
    this.setChecked(checked, halfChecked);
    if (this.treeService && !this.treeService.isCheckStrictly) {
      this.treeService.conduct(this);
    }
  }
  setChecked(checked = false, halfChecked = false) {
    this.origin.checked = checked;
    this.isChecked = checked;
    this.isHalfChecked = halfChecked;
  }
  setExpanded(value) {
    this._isExpanded = value;
    this.origin.expanded = value;
    this.afterValueChange("isExpanded");
  }
  getParentNode() {
    return this.parentNode;
  }
  getChildren() {
    return this.children;
  }
  /**
   * Support appending child nodes by position. Leaf node cannot be appended.
   */
  addChildren(children, childPos = -1) {
    if (!this.isLeaf) {
      children.forEach((node) => {
        const refreshLevel = (n) => {
          n.getChildren().forEach((c) => {
            c.level = c.getParentNode().level + 1;
            c.origin.level = c.level;
            refreshLevel(c);
          });
        };
        let child = node;
        if (child instanceof _NzTreeNode) {
          child.parentNode = this;
        } else {
          child = new _NzTreeNode(node, this);
        }
        child.level = this.level + 1;
        child.origin.level = child.level;
        refreshLevel(child);
        try {
          childPos === -1 ? this.children.push(child) : this.children.splice(childPos, 0, child);
        } catch (e) {
        }
      });
      this.origin.children = this.getChildren().map((v) => v.origin);
      this.isLoading = false;
    }
    this.afterValueChange("addChildren");
    this.afterValueChange("reRender");
  }
  clearChildren() {
    this.afterValueChange("clearChildren");
    this.children = [];
    this.origin.children = [];
    this.afterValueChange("reRender");
  }
  remove() {
    const parentNode = this.getParentNode();
    if (parentNode) {
      parentNode.children = parentNode.getChildren().filter((v) => v.key !== this.key);
      parentNode.origin.children = parentNode.origin.children.filter((v) => v.key !== this.key);
      this.afterValueChange("remove");
      this.afterValueChange("reRender");
    }
  }
  afterValueChange(key) {
    if (this.treeService) {
      switch (key) {
        case "isChecked":
          this.treeService.setCheckedNodeList(this);
          break;
        case "isHalfChecked":
          this.treeService.setHalfCheckedNodeList(this);
          break;
        case "isExpanded":
          this.treeService.setExpandedNodeList(this);
          break;
        case "isSelected":
          this.treeService.setNodeActive(this);
          break;
        case "clearChildren":
          this.treeService.afterRemove(this.getChildren());
          break;
        case "remove":
          this.treeService.afterRemove([this]);
          break;
        case "reRender":
          this.treeService.flattenTreeData(this.treeService.rootNodes, this.treeService.getExpandedNodeList().map((v) => v.key));
          break;
      }
    }
    this.update();
  }
  update() {
    if (this.component) {
      this.component.markForCheck();
    }
  }
};
function isCheckDisabled(node) {
  const {
    isDisabled,
    isDisableCheckbox
  } = node;
  return !!(isDisabled || isDisableCheckbox);
}
function isInArray(needle, haystack) {
  return haystack.length > 0 && haystack.indexOf(needle) > -1;
}
function getPosition(level, index) {
  return `${level}-${index}`;
}
function getKey(key, pos) {
  if (key !== null && key !== void 0) {
    return key;
  }
  return pos;
}
function flattenTreeData(treeNodeList = [], expandedKeys = []) {
  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  const flattenList = [];
  function dig(list, parent = null) {
    return list.map((treeNode, index) => {
      const pos = getPosition(parent ? parent.pos : "0", index);
      const mergedKey = getKey(treeNode.key, pos);
      treeNode.isStart = [...parent ? parent.isStart : [], index === 0];
      treeNode.isEnd = [...parent ? parent.isEnd : [], index === list.length - 1];
      const flattenNode = {
        parent,
        pos,
        children: [],
        data: treeNode,
        isStart: [...parent ? parent.isStart : [], index === 0],
        isEnd: [...parent ? parent.isEnd : [], index === list.length - 1]
      };
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {
        flattenNode.children = dig(treeNode.children || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
var _NzTreeBaseService = class _NzTreeBaseService {
  constructor() {
    this.DRAG_SIDE_RANGE = 0.25;
    this.DRAG_MIN_GAP = 2;
    this.isCheckStrictly = false;
    this.isMultiple = false;
    this.rootNodes = [];
    this.flattenNodes$ = new BehaviorSubject([]);
    this.selectedNodeList = [];
    this.expandedNodeList = [];
    this.checkedNodeList = [];
    this.halfCheckedNodeList = [];
    this.matchedNodeList = [];
  }
  /**
   * reset tree nodes will clear default node list
   */
  initTree(nzNodes) {
    this.rootNodes = nzNodes;
    this.expandedNodeList = [];
    this.selectedNodeList = [];
    this.halfCheckedNodeList = [];
    this.checkedNodeList = [];
    this.matchedNodeList = [];
  }
  flattenTreeData(nzNodes, expandedKeys = []) {
    this.flattenNodes$.next(flattenTreeData(nzNodes, expandedKeys).map((item) => item.data));
  }
  getSelectedNode() {
    return this.selectedNode;
  }
  /**
   * get some list
   */
  getSelectedNodeList() {
    return this.conductNodeState("select");
  }
  /**
   * get checked node keys
   */
  getCheckedNodeKeys() {
    const keys = [];
    const checkedNodes = this.getCheckedNodeList();
    const calc = (nodes) => {
      nodes.forEach((node) => {
        keys.push(node.key);
        if (node.children.length < 1)
          return;
        calc(node.children);
      });
    };
    calc(checkedNodes);
    return keys;
  }
  /**
   * return checked nodes
   */
  getCheckedNodeList() {
    return this.conductNodeState("check");
  }
  getHalfCheckedNodeList() {
    return this.conductNodeState("halfCheck");
  }
  /**
   * return expanded nodes
   */
  getExpandedNodeList() {
    return this.conductNodeState("expand");
  }
  /**
   * return search matched nodes
   */
  getMatchedNodeList() {
    return this.conductNodeState("match");
  }
  isArrayOfNzTreeNode(value) {
    return value.every((item) => item instanceof NzTreeNode);
  }
  /**
   * set drag node
   */
  setSelectedNode(node) {
    this.selectedNode = node;
  }
  /**
   * set node selected status
   */
  setNodeActive(node) {
    if (!this.isMultiple && node.isSelected) {
      this.selectedNodeList.forEach((n) => {
        if (node.key !== n.key) {
          n.isSelected = false;
        }
      });
      this.selectedNodeList = [];
    }
    this.setSelectedNodeList(node, this.isMultiple);
  }
  /**
   * add or remove node to selectedNodeList
   */
  setSelectedNodeList(node, isMultiple = false) {
    const index = this.getIndexOfArray(this.selectedNodeList, node.key);
    if (isMultiple) {
      if (node.isSelected && index === -1) {
        this.selectedNodeList.push(node);
      }
    } else {
      if (node.isSelected && index === -1) {
        this.selectedNodeList = [node];
      }
    }
    if (!node.isSelected) {
      this.selectedNodeList = this.selectedNodeList.filter((n) => n.key !== node.key);
    }
  }
  /**
   * merge checked nodes
   */
  setHalfCheckedNodeList(node) {
    const index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);
    if (node.isHalfChecked && index === -1) {
      this.halfCheckedNodeList.push(node);
    } else if (!node.isHalfChecked && index > -1) {
      this.halfCheckedNodeList = this.halfCheckedNodeList.filter((n) => node.key !== n.key);
    }
  }
  setCheckedNodeList(node) {
    const index = this.getIndexOfArray(this.checkedNodeList, node.key);
    if (node.isChecked && index === -1) {
      this.checkedNodeList.push(node);
    } else if (!node.isChecked && index > -1) {
      this.checkedNodeList = this.checkedNodeList.filter((n) => node.key !== n.key);
    }
  }
  /**
   * conduct checked/selected/expanded keys
   */
  conductNodeState(type = "check") {
    let resultNodesList = [];
    switch (type) {
      case "select":
        resultNodesList = this.selectedNodeList;
        break;
      case "expand":
        resultNodesList = this.expandedNodeList;
        break;
      case "match":
        resultNodesList = this.matchedNodeList;
        break;
      case "check":
        resultNodesList = this.checkedNodeList;
        const isIgnore = (node) => {
          const parentNode = node.getParentNode();
          if (parentNode) {
            if (this.checkedNodeList.findIndex((n) => n.key === parentNode.key) > -1) {
              return true;
            } else {
              return isIgnore(parentNode);
            }
          }
          return false;
        };
        if (!this.isCheckStrictly) {
          resultNodesList = this.checkedNodeList.filter((n) => !isIgnore(n));
        }
        break;
      case "halfCheck":
        if (!this.isCheckStrictly) {
          resultNodesList = this.halfCheckedNodeList;
        }
        break;
    }
    return resultNodesList;
  }
  /**
   * set expanded nodes
   */
  setExpandedNodeList(node) {
    if (node.isLeaf) {
      return;
    }
    const index = this.getIndexOfArray(this.expandedNodeList, node.key);
    if (node.isExpanded && index === -1) {
      this.expandedNodeList.push(node);
    } else if (!node.isExpanded && index > -1) {
      this.expandedNodeList.splice(index, 1);
    }
  }
  setMatchedNodeList(node) {
    const index = this.getIndexOfArray(this.matchedNodeList, node.key);
    if (node.isMatched && index === -1) {
      this.matchedNodeList.push(node);
    } else if (!node.isMatched && index > -1) {
      this.matchedNodeList.splice(index, 1);
    }
  }
  /**
   * check state
   *
   * @param isCheckStrictly
   */
  refreshCheckState(isCheckStrictly = false) {
    if (isCheckStrictly) {
      return;
    }
    this.checkedNodeList.forEach((node) => {
      this.conduct(node, isCheckStrictly);
    });
  }
  // reset other node checked state based current node
  conduct(node, isCheckStrictly = false) {
    const isChecked = node.isChecked;
    if (node && !isCheckStrictly) {
      this.conductUp(node);
      this.conductDown(node, isChecked);
    }
  }
  /**
   * 1、children half checked
   * 2、children all checked, parent checked
   * 3、no children checked
   */
  conductUp(node) {
    const parentNode = node.getParentNode();
    if (parentNode) {
      if (!isCheckDisabled(parentNode)) {
        if (parentNode.children.every((child) => isCheckDisabled(child) || !child.isHalfChecked && child.isChecked)) {
          parentNode.isChecked = true;
          parentNode.isHalfChecked = false;
        } else if (parentNode.children.some((child) => child.isHalfChecked || child.isChecked)) {
          parentNode.isChecked = false;
          parentNode.isHalfChecked = true;
        } else {
          parentNode.isChecked = false;
          parentNode.isHalfChecked = false;
        }
      }
      this.setCheckedNodeList(parentNode);
      this.setHalfCheckedNodeList(parentNode);
      this.conductUp(parentNode);
    }
  }
  /**
   * reset child check state
   */
  conductDown(node, value) {
    if (!isCheckDisabled(node)) {
      node.isChecked = value;
      node.isHalfChecked = false;
      this.setCheckedNodeList(node);
      this.setHalfCheckedNodeList(node);
      node.children.forEach((n) => {
        this.conductDown(n, value);
      });
    }
  }
  /**
   * flush after delete node
   */
  afterRemove(nodes) {
    const loopNode = (node) => {
      this.selectedNodeList = this.selectedNodeList.filter((n) => n.key !== node.key);
      this.expandedNodeList = this.expandedNodeList.filter((n) => n.key !== node.key);
      this.checkedNodeList = this.checkedNodeList.filter((n) => n.key !== node.key);
      if (node.children) {
        node.children.forEach((child) => {
          loopNode(child);
        });
      }
    };
    nodes.forEach((n) => {
      loopNode(n);
    });
    this.refreshCheckState(this.isCheckStrictly);
  }
  /**
   * drag event
   */
  refreshDragNode(node) {
    if (node.children.length === 0) {
      this.conductUp(node);
    } else {
      node.children.forEach((child) => {
        this.refreshDragNode(child);
      });
    }
  }
  // reset node level
  resetNodeLevel(node) {
    const parentNode = node.getParentNode();
    if (parentNode) {
      node.level = parentNode.level + 1;
    } else {
      node.level = 0;
    }
    for (const child of node.children) {
      this.resetNodeLevel(child);
    }
  }
  calcDropPosition(event) {
    const {
      clientY
    } = event;
    const {
      top,
      bottom,
      height
    } = event.target.getBoundingClientRect();
    const des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);
    if (clientY <= top + des) {
      return -1;
    } else if (clientY >= bottom - des) {
      return 1;
    }
    return 0;
  }
  /**
   * drop
   * 0: inner -1: pre 1: next
   */
  dropAndApply(targetNode, dragPos = -1) {
    if (!targetNode || dragPos > 1) {
      return;
    }
    const treeService = targetNode.treeService;
    const targetParent = targetNode.getParentNode();
    const isSelectedRootNode = this.selectedNode.getParentNode();
    if (isSelectedRootNode) {
      isSelectedRootNode.children = isSelectedRootNode.children.filter((n) => n.key !== this.selectedNode.key);
    } else {
      this.rootNodes = this.rootNodes.filter((n) => n.key !== this.selectedNode.key);
    }
    switch (dragPos) {
      case 0:
        targetNode.addChildren([this.selectedNode]);
        this.resetNodeLevel(targetNode);
        break;
      case -1:
      case 1:
        const tIndex = dragPos === 1 ? 1 : 0;
        if (targetParent) {
          targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);
          const parentNode = this.selectedNode.getParentNode();
          if (parentNode) {
            this.resetNodeLevel(parentNode);
          }
        } else {
          const targetIndex = this.rootNodes.indexOf(targetNode) + tIndex;
          this.rootNodes.splice(targetIndex, 0, this.selectedNode);
          this.rootNodes[targetIndex].parentNode = null;
          this.resetNodeLevel(this.rootNodes[targetIndex]);
        }
        break;
    }
    this.rootNodes.forEach((child) => {
      if (!child.treeService) {
        child.service = treeService;
      }
      this.refreshDragNode(child);
    });
  }
  /**
   * emit Structure
   * eventName
   * node
   * event: MouseEvent / DragEvent
   * dragNode
   */
  formatEvent(eventName, node, event) {
    const emitStructure = {
      eventName,
      node,
      event
    };
    switch (eventName) {
      case "dragstart":
      case "dragenter":
      case "dragover":
      case "dragleave":
      case "drop":
      case "dragend":
        Object.assign(emitStructure, {
          dragNode: this.getSelectedNode()
        });
        break;
      case "click":
      case "dblclick":
        Object.assign(emitStructure, {
          selectedKeys: this.selectedNodeList
        });
        Object.assign(emitStructure, {
          nodes: this.selectedNodeList
        });
        Object.assign(emitStructure, {
          keys: this.selectedNodeList.map((n) => n.key)
        });
        break;
      case "check":
        const checkedNodeList = this.getCheckedNodeList();
        Object.assign(emitStructure, {
          checkedKeys: checkedNodeList
        });
        Object.assign(emitStructure, {
          nodes: checkedNodeList
        });
        Object.assign(emitStructure, {
          keys: checkedNodeList.map((n) => n.key)
        });
        break;
      case "search":
        Object.assign(emitStructure, {
          matchedKeys: this.getMatchedNodeList()
        });
        Object.assign(emitStructure, {
          nodes: this.getMatchedNodeList()
        });
        Object.assign(emitStructure, {
          keys: this.getMatchedNodeList().map((n) => n.key)
        });
        break;
      case "expand":
        Object.assign(emitStructure, {
          nodes: this.expandedNodeList
        });
        Object.assign(emitStructure, {
          keys: this.expandedNodeList.map((n) => n.key)
        });
        break;
    }
    return emitStructure;
  }
  /**
   * New functions for flatten nodes
   */
  getIndexOfArray(list, key) {
    return list.findIndex((v) => v.key === key);
  }
  /**
   * Render by nzCheckedKeys
   * When keys equals null, just render with checkStrictly
   *
   * @param keys
   * @param checkStrictly
   */
  conductCheck(keys, checkStrictly) {
    this.checkedNodeList = [];
    this.halfCheckedNodeList = [];
    const calc = (nodes) => {
      nodes.forEach((node) => {
        if (keys === null) {
          node.isChecked = !!node.origin.checked;
        } else {
          if (isInArray(node.key, keys || [])) {
            node.isChecked = true;
            node.isHalfChecked = false;
          } else {
            node.isChecked = false;
            node.isHalfChecked = false;
          }
        }
        if (node.children.length > 0) {
          calc(node.children);
        }
      });
    };
    calc(this.rootNodes);
    this.refreshCheckState(checkStrictly);
  }
  conductExpandedKeys(keys = []) {
    const expandedKeySet = new Set(keys === true ? [] : keys);
    this.expandedNodeList = [];
    const calc = (nodes) => {
      nodes.forEach((node) => {
        node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);
        if (node.isExpanded) {
          this.setExpandedNodeList(node);
        }
        if (node.children.length > 0) {
          calc(node.children);
        }
      });
    };
    calc(this.rootNodes);
  }
  conductSelectedKeys(keys, isMulti) {
    this.selectedNodeList.forEach((node) => node.isSelected = false);
    this.selectedNodeList = [];
    const calc = (nodes) => nodes.every((node) => {
      if (isInArray(node.key, keys)) {
        node.isSelected = true;
        this.setSelectedNodeList(node);
        if (!isMulti) {
          return false;
        }
      } else {
        node.isSelected = false;
      }
      if (node.children.length > 0) {
        return calc(node.children);
      }
      return true;
    });
    calc(this.rootNodes);
  }
  /**
   * Expand parent nodes by child node
   *
   * @param node
   */
  expandNodeAllParentBySearch(node) {
    const calc = (n) => {
      if (n) {
        n.canHide = false;
        n.setExpanded(true);
        this.setExpandedNodeList(n);
        if (n.getParentNode()) {
          return calc(n.getParentNode());
        }
      }
    };
    calc(node.getParentNode());
  }
};
_NzTreeBaseService.ɵfac = function NzTreeBaseService_Factory(t) {
  return new (t || _NzTreeBaseService)();
};
_NzTreeBaseService.ɵprov = ɵɵdefineInjectable({
  token: _NzTreeBaseService,
  factory: _NzTreeBaseService.ɵfac
});
var NzTreeBaseService = _NzTreeBaseService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NzTreeBaseService, [{
    type: Injectable
  }], null, null);
})();
var NzTreeHigherOrderServiceToken = new InjectionToken("NzTreeHigherOrder");

// node_modules/@delon/util/fesm2022/array.mjs
var _ArrayService = class _ArrayService {
  constructor(cog) {
    this.c = cog.merge("utilArray", {
      deepMapName: "deep",
      parentMapName: "parent",
      idMapName: "id",
      parentIdMapName: "parent_id",
      childrenMapName: "children",
      titleMapName: "title",
      checkedMapname: "checked",
      selectedMapname: "selected",
      expandedMapname: "expanded",
      disabledMapname: "disabled"
    });
  }
  /**
   * Convert tree structure to array structure
   *
   * 将树结构转换成数组结构
   */
  treeToArr(tree, options) {
    const opt = __spreadValues({
      deepMapName: this.c.deepMapName,
      parentMapName: this.c.parentMapName,
      childrenMapName: this.c.childrenMapName,
      clearChildren: true,
      cb: null
    }, options);
    const result = [];
    const inFn = (list, parent, deep = 0) => {
      for (const i of list) {
        i[opt.deepMapName] = deep;
        i[opt.parentMapName] = parent;
        if (opt.cb) {
          opt.cb(i, parent, deep);
        }
        result.push(i);
        const children = i[opt.childrenMapName];
        if (children != null && Array.isArray(children) && children.length > 0) {
          inFn(children, i, deep + 1);
        }
        if (opt.clearChildren) {
          delete i[opt.childrenMapName];
        }
      }
    };
    inFn(tree, null);
    return result;
  }
  /**
   * Convert array structure to tree structure
   *
   * 数组转换成树数据
   */
  arrToTree(arr, options) {
    if (!Array.isArray(arr) || arr.length === 0) {
      return [];
    }
    const opt = __spreadValues({
      idMapName: this.c.idMapName,
      parentIdMapName: this.c.parentIdMapName,
      childrenMapName: this.c.childrenMapName,
      cb: null
    }, options);
    const tree = [];
    const childrenOf = {};
    let rootPid = opt.rootParentIdValue;
    const arrType = arr;
    if (!rootPid) {
      const pids = arrType.map((i) => i[opt.parentIdMapName]);
      const emptyPid = pids.findIndex((w) => w == null);
      rootPid = emptyPid !== -1 ? pids[emptyPid] : pids.sort()[0];
    }
    for (const item of arrType) {
      const id = item[opt.idMapName];
      const pid = item[opt.parentIdMapName];
      childrenOf[id] = childrenOf[id] || [];
      item[opt.childrenMapName] = childrenOf[id];
      if (opt.cb) {
        opt.cb(item);
      }
      if (pid !== rootPid) {
        childrenOf[pid] = childrenOf[pid] || [];
        childrenOf[pid].push(item);
      } else {
        tree.push(item);
      }
    }
    return tree;
  }
  /**
   * 数组转换成 `nz-tree` 数据源，通过 `options` 转化项名，也可以使用 `options.cb` 更高级决定数据项
   */
  arrToTreeNode(arr, options) {
    const opt = __spreadValues({
      idMapName: this.c.idMapName,
      parentIdMapName: this.c.parentIdMapName,
      titleMapName: this.c.titleMapName,
      isLeafMapName: "isLeaf",
      checkedMapname: this.c.checkedMapname,
      selectedMapname: this.c.selectedMapname,
      expandedMapname: this.c.expandedMapname,
      disabledMapname: this.c.disabledMapname,
      cb: null
    }, options);
    const tree = this.arrToTree(arr, {
      idMapName: opt.idMapName,
      parentIdMapName: opt.parentIdMapName,
      childrenMapName: "children"
    });
    this.visitTree(tree, (item, parent, deep) => {
      item.key = item[opt.idMapName];
      item.title = item[opt.titleMapName];
      item.checked = item[opt.checkedMapname];
      item.selected = item[opt.selectedMapname];
      item.expanded = item[opt.expandedMapname];
      item.disabled = item[opt.disabledMapname];
      if (item[opt.isLeafMapName] == null) {
        item.isLeaf = item.children.length === 0;
      } else {
        item.isLeaf = item[opt.isLeafMapName];
      }
      if (opt.cb) {
        opt.cb(item, parent, deep);
      }
    });
    return tree.map((node) => new NzTreeNode(node));
  }
  /**
   * 递归访问整个树
   */
  visitTree(tree, cb, options) {
    options = __spreadValues({
      childrenMapName: this.c.childrenMapName
    }, options);
    const inFn = (data, parent, deep) => {
      for (const item of data) {
        cb(item, parent, deep);
        const childrenVal = item[options.childrenMapName];
        if (Array.isArray(childrenVal) && childrenVal.length > 0) {
          inFn(childrenVal, item, deep + 1);
        }
      }
    };
    inFn(tree, null, 1);
  }
  /**
   * Return the value of the first tree value in the tree where predicate is true, and `undefined` otherwise
   *
   * 根据条件返回树的第一个值，否则返回 `undefined`
   */
  findTree(tree, predicate, options) {
    let res;
    this.visitTree(tree, (item) => {
      if (res === void 0 && predicate(item)) {
        res = item;
      }
    }, options);
    return res;
  }
  /**
   * 获取所有已经选中的 `key` 值
   */
  getKeysByTreeNode(tree, options) {
    const opt = __spreadValues({
      includeHalfChecked: true
    }, options);
    const keys = [];
    this.visitTree(tree, (item, parent, deep) => {
      if (item.isChecked || opt.includeHalfChecked && item.isHalfChecked) {
        keys.push(opt.cb ? opt.cb(item, parent, deep) : opt.keyMapName ? item.origin[opt.keyMapName] : item.key);
      }
    });
    return keys;
  }
  baseFlat(array, depth, result = []) {
    let index = -1;
    while (++index < array.length) {
      const value = array[index];
      if (depth > 0 && Array.isArray(value)) {
        if (depth > 1) {
          this.baseFlat(value, depth - 1, result);
        } else {
          let pushIndex = -1;
          const offset = result.length;
          while (++pushIndex < value.length) {
            result[offset + pushIndex] = value[pushIndex];
          }
        }
      } else {
        result[result.length] = value;
      }
    }
    return result;
  }
  /**
   * Recursively flattens array
   *
   * 递归扁平数组
   * ```ts
   * srv.flat([1, [2, 3, [4, 5, [6]]]]) => [1,2,3,4,5,6]
   * srv.flat([1, [2, 3, [4, 5, [6]]]], 1) => [1,2,3,[4, 5, [6]]]
   * ```
   */
  flat(array, depth = 1 / 0) {
    return Array.isArray(array) ? this.baseFlat(array, depth) : array;
  }
  /**
   * Group the array
   *
   * 对数组进行分组
   * ```ts
   * srv.groupBy([6.1, 4.2, 6.3], Math.floor) => {"4":[4.2],"6":[6.1,6.3]}
   * srv.groupBy(['one', 'two', 'three'], v => v.length) => {"3":["one","two"],"5":["three"]}
   * ```
   */
  groupBy(array, iteratee) {
    if (!Array.isArray(array)) {
      return {};
    }
    return array.reduce((result, value) => {
      const key = iteratee(value);
      if (Object.prototype.hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
      return result;
    }, {});
  }
  /**
   * Creates a duplicate-free version of an array
   *
   * 创建去重后的数组
   * ```ts
   * uniq([1, 2, 2, 3, 1]) => [1,2,3]
   * uniq([{ a: 1 }, { a: 1 }, { a: 2 }], 'a') => [{"a":1},{"a":2}]
   * uniq([{ a: 1 }, { a: 1 }, { a: 2 }], i => (i.a === 1 ? 'a' : 'b')) => [{"a":1},{"a":2}]
   * ```
   */
  uniq(array, predicate) {
    return Array.from(array.reduce((map2, value) => {
      const key = predicate ? typeof predicate === "string" ? value[predicate] : predicate(value) : value;
      if (!map2.has(key)) {
        map2.set(key, value);
      }
      return map2;
    }, /* @__PURE__ */ new Map()).values());
  }
};
_ArrayService.ɵfac = function ArrayService_Factory(t) {
  return new (t || _ArrayService)(ɵɵinject(AlainConfigService));
};
_ArrayService.ɵprov = ɵɵdefineInjectable({
  token: _ArrayService,
  factory: _ArrayService.ɵfac,
  providedIn: "root"
});
var ArrayService = _ArrayService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ArrayService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: AlainConfigService
  }], null);
})();

// node_modules/@delon/form/fesm2022/form.mjs
var _c0 = ["target"];
function SFItemComponent_ng_template_0_Template(rf, ctx) {
}
function SFItemComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function SFComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "i", 10);
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext(5);
    ɵɵproperty("nzType", ctx_r10._btn.submit_icon.type)("nzTheme", ctx_r10._btn.submit_icon.theme)("nzTwotoneColor", ctx_r10._btn.submit_icon.twoToneColor)("nzIconfont", ctx_r10._btn.submit_icon.iconfont);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "i", 10);
  }
  if (rf & 2) {
    const ctx_r12 = ɵɵnextContext(6);
    ɵɵproperty("nzType", ctx_r12._btn.reset_icon.type)("nzTheme", ctx_r12._btn.reset_icon.theme)("nzTwotoneColor", ctx_r12._btn.reset_icon.twoToneColor)("nzIconfont", ctx_r12._btn.reset_icon.iconfont);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵlistener("click", function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r13 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r13.reset(true));
    });
    ɵɵtemplate(1, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Conditional_1_Template, 1, 4, "i", 10);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r11 = ɵɵnextContext(5);
    ɵɵproperty("nzType", ctx_r11._btn.reset_type)("nzSize", ctx_r11._btn.render.size)("disabled", ctx_r11.loading);
    ɵɵadvance();
    ɵɵconditional(1, ctx_r11._btn.reset_icon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r11._btn.reset, " ");
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 9);
    ɵɵtemplate(1, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_1_Template, 1, 4, "i", 10);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Conditional_3_Template, 3, 5, "button", 11);
  }
  if (rf & 2) {
    const ctx_r8 = ɵɵnextContext(4);
    ɵɵproperty("nzType", ctx_r8._btn.submit_type)("nzSize", ctx_r8._btn.render.size)("nzLoading", ctx_r8.loading)("disabled", ctx_r8.liveValidate && !ctx_r8.valid);
    ɵɵadvance();
    ɵɵconditional(1, ctx_r8._btn.submit_icon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r8._btn.submit, " ");
    ɵɵadvance();
    ɵɵconditional(3, ctx_r8._btn.reset ? 3 : -1);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_5_ng_template_0_Template(rf, ctx) {
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_5_ng_template_0_Template, 0, 0, "ng-template", 13);
  }
  if (rf & 2) {
    ɵɵnextContext(4);
    const _r1 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", _r1);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-form-item", 5)(1, "div", 6)(2, "div", 7)(3, "div", 8);
    ɵɵtemplate(4, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_4_Template, 4, 7)(5, SFComponent_ng_template_2_Conditional_0_Conditional_0_Conditional_5_Template, 1, 1);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext(3);
    ɵɵproperty("ngClass", ctx_r7._btn.render.class)("fixed-label", ctx_r7._btn.render.spanLabelFixed);
    ɵɵadvance();
    ɵɵproperty("nzSpan", ctx_r7.btnGrid.span)("nzOffset", ctx_r7.btnGrid.offset)("nzXs", ctx_r7.btnGrid.xs)("nzSm", ctx_r7.btnGrid.sm)("nzMd", ctx_r7.btnGrid.md)("nzLg", ctx_r7.btnGrid.lg)("nzXl", ctx_r7.btnGrid.xl)("nzXXl", ctx_r7.btnGrid.xxl);
    ɵɵadvance(3);
    ɵɵconditional(4, ctx_r7.button ? 4 : 5);
  }
}
function SFComponent_ng_template_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SFComponent_ng_template_2_Conditional_0_Conditional_0_Template, 6, 11, "nz-form-item", 4);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵconditional(0, ctx_r5._btn && ctx_r5._btn.render ? 0 : -1);
  }
}
function SFComponent_ng_template_2_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function SFComponent_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SFComponent_ng_template_2_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 13);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const _r1 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", _r1);
  }
}
function SFComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SFComponent_ng_template_2_Conditional_0_Template, 1, 1)(1, SFComponent_ng_template_2_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵconditional(0, ctx_r2.button !== "none" ? 0 : 1);
  }
}
function SFComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "sf-item", 3);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const _r3 = ɵɵreference(3);
    ɵɵproperty("formProperty", ctx_r4.rootProperty)("footer", _r3);
  }
}
var _c1 = ["*"];
function SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "i", 11);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(4);
    ɵɵproperty("nzTooltipTitle", ctx_r5.oh.text)("nzTooltipPlacement", ctx_r5.oh.placement)("nzTooltipTrigger", ctx_r5.oh.trigger)("nzTooltipColor", ctx_r5.oh.bgColor)("nzTooltipOverlayClassName", ctx_r5.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r5.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r5.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r5.oh.mouseLeaveDelay)("nzType", ctx_r5.oh.icon);
  }
}
function SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵtemplate(2, SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Conditional_2_Template, 1, 9, "i", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.ui.optional, " ");
    ɵɵadvance();
    ɵɵconditional(2, ctx_r4.oh ? 2 : -1);
  }
}
function SFItemWrapComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label")(1, "span", 8);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Template, 3, 2, "span", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵclassProp("ant-form-item-required", ctx_r3.ui._required);
    ɵɵattribute("for", ctx_r3.id);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.t);
    ɵɵadvance();
    ɵɵconditional(3, ctx_r3.ui.optional || ctx_r3.oh ? 3 : -1);
  }
}
function SFItemWrapComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, SFItemWrapComponent_Conditional_1_Conditional_1_Template, 4, 5, "label", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("nzSpan", ctx_r0.ui.spanLabel);
    ɵɵadvance();
    ɵɵconditional(1, ctx_r0.t ? 1 : -1);
  }
}
function SFItemWrapComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12)(1, "div", 13);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("@helpMotion", void 0);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.error, " ");
  }
}
function SFItemWrapComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 14);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r2.ui._description, ɵɵsanitizeHtml);
  }
}
function ArrayWidget_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "i", 9);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("nzTooltipTitle", ctx_r4.oh.text)("nzTooltipPlacement", ctx_r4.oh.placement)("nzTooltipTrigger", ctx_r4.oh.trigger)("nzTooltipOverlayClassName", ctx_r4.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r4.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r4.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r4.oh.mouseLeaveDelay)("nzType", ctx_r4.oh.icon);
  }
}
function ArrayWidget_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7)(1, "label");
    ɵɵtext(2);
    ɵɵelementStart(3, "span", 8);
    ɵɵtext(4);
    ɵɵtemplate(5, ArrayWidget_Conditional_1_Conditional_5_Template, 1, 8, "i", 9);
    ɵɵelementEnd()();
    ɵɵelementStart(6, "div", 10)(7, "button", 11);
    ɵɵlistener("click", function ArrayWidget_Conditional_1_Template_button_click_7_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.addItem());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("nzSpan", ctx_r0.ui.spanLabel);
    ɵɵadvance();
    ɵɵclassProp("ant-form-item-required", ctx_r0.ui.required);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.schema.title, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.ui.optional, " ");
    ɵɵadvance();
    ɵɵconditional(5, ctx_r0.oh ? 5 : -1);
    ɵɵadvance(2);
    ɵɵproperty("nzType", ctx_r0.addType)("disabled", ctx_r0.addDisabled)("innerHTML", ctx_r0.addTitle, ɵɵsanitizeHtml);
  }
}
function ArrayWidget_ng_container_5_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 16);
    ɵɵlistener("click", function ArrayWidget_ng_container_5_Conditional_1_Conditional_3_Template_span_click_0_listener() {
      ɵɵrestoreView(_r13);
      const $index_r8 = ɵɵnextContext(2).index;
      const ctx_r11 = ɵɵnextContext();
      return ɵɵresetView(ctx_r11.removeItem($index_r8));
    });
    ɵɵelement(1, "i", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext(3);
    ɵɵattribute("title", ctx_r10.removeTitle);
  }
}
function ArrayWidget_ng_container_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13)(1, "nz-card");
    ɵɵelement(2, "sf-item", 14);
    ɵɵtemplate(3, ArrayWidget_ng_container_5_Conditional_1_Conditional_3_Template, 2, 1, "span", 15);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r14 = ɵɵnextContext();
    const $index_r8 = ctx_r14.index;
    const i_r7 = ctx_r14.$implicit;
    const ctx_r9 = ɵɵnextContext();
    ɵɵproperty("nzSpan", ctx_r9.arraySpan);
    ɵɵattribute("data-index", $index_r8);
    ɵɵadvance(2);
    ɵɵproperty("formProperty", i_r7);
    ɵɵadvance();
    ɵɵconditional(3, ctx_r9.showRemove ? 3 : -1);
  }
}
function ArrayWidget_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ArrayWidget_ng_container_5_Conditional_1_Template, 4, 4, "div", 12);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const i_r7 = ctx.$implicit;
    ɵɵadvance();
    ɵɵconditional(1, i_r7.visible && !i_r7.ui.hidden ? 1 : -1);
  }
}
function ArrayWidget_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.error);
  }
}
function ArrayWidget_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 19);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r3.ui._description, ɵɵsanitizeHtml);
  }
}
function CheckboxWidget_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "label", 3);
    ɵɵtwoWayListener("ngModelChange", function CheckboxWidget_ng_template_0_Conditional_0_Template_label_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r4.allChecked, $event) || (ctx_r4.allChecked = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function CheckboxWidget_ng_template_0_Conditional_0_Template_label_ngModelChange_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r6 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r6.onAllChecked());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵtwoWayProperty("ngModel", ctx_r3.allChecked);
    ɵɵproperty("nzIndeterminate", ctx_r3.indeterminate);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.ui.checkAllText || ctx_r3.l.checkAllText, " ");
  }
}
function CheckboxWidget_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CheckboxWidget_ng_template_0_Conditional_0_Template, 2, 3, "label", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(0, ctx_r0.ui.checkAll ? 0 : -1);
  }
}
function CheckboxWidget_Conditional_3_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "i", 7);
  }
  if (rf & 2) {
    const ctx_r9 = ɵɵnextContext(3);
    ɵɵproperty("nzTooltipTitle", ctx_r9.oh.text)("nzTooltipPlacement", ctx_r9.oh.placement)("nzTooltipTrigger", ctx_r9.oh.trigger)("nzTooltipOverlayClassName", ctx_r9.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r9.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r9.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r9.oh.mouseLeaveDelay)("nzType", ctx_r9.oh.icon);
  }
}
function CheckboxWidget_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "label", 5);
    ɵɵlistener("ngModelChange", function CheckboxWidget_Conditional_3_Conditional_0_Template_label_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r10 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r10._setValue($event));
    });
    ɵɵtext(1);
    ɵɵelementStart(2, "span", 6);
    ɵɵtext(3);
    ɵɵtemplate(4, CheckboxWidget_Conditional_3_Conditional_0_Conditional_4_Template, 1, 8, "i", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext(2);
    ɵɵproperty("nzDisabled", ctx_r7.disabled)("ngModel", ctx_r7.value);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r7.schema.title, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r7.ui.optional, " ");
    ɵɵadvance();
    ɵɵconditional(4, ctx_r7.oh ? 4 : -1);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵtemplate(0, CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 8);
    ɵɵelementStart(1, "nz-checkbox-group", 9);
    ɵɵlistener("ngModelChange", function CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_Template_nz_checkbox_group_ngModelChange_1_listener() {
      ɵɵrestoreView(_r16);
      const ctx_r15 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r15.notifySet());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r12 = ɵɵnextContext(3);
    const _r1 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", _r1);
    ɵɵadvance();
    ɵɵproperty("ngModel", ctx_r12.data);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_ng_template_1_Template(rf, ctx) {
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtemplate(1, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r17 = ɵɵnextContext(4);
    const _r1 = ɵɵreference(1);
    ɵɵproperty("nzSpan", ctx_r17.grid_span);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r1);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_For_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12)(1, "label", 13);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const i_r20 = ctx.$implicit;
    const ctx_r18 = ɵɵnextContext(4);
    ɵɵproperty("nzSpan", ctx_r18.grid_span);
    ɵɵadvance();
    ɵɵproperty("nzValue", i_r20.value)("ngModel", i_r20.checked)("nzDisabled", i_r20.disabled);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", i_r20.label, " ");
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r26 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-checkbox-wrapper", 10);
    ɵɵlistener("nzOnChange", function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Template_nz_checkbox_wrapper_nzOnChange_0_listener($event) {
      ɵɵrestoreView(_r26);
      const ctx_r25 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r25.groupInGridChange($event));
    });
    ɵɵelementStart(1, "div", 11);
    ɵɵtemplate(2, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_Template, 2, 2, "div", 12);
    ɵɵrepeaterCreate(3, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_For_4_Template, 3, 5, "div", 12, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵconditional(2, ctx_r13.ui.checkAll ? 2 : -1);
    ɵɵadvance();
    ɵɵrepeater(ctx_r13.data);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_Template, 2, 2)(1, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Template, 5, 1);
  }
  if (rf & 2) {
    const ctx_r8 = ɵɵnextContext(2);
    ɵɵconditional(0, ctx_r8.grid_span === 0 ? 0 : 1);
  }
}
function CheckboxWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CheckboxWidget_Conditional_3_Conditional_0_Template, 5, 5, "label", 4)(1, CheckboxWidget_Conditional_3_Conditional_1_Template, 2, 1);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵconditional(0, ctx_r2.data.length === 0 ? 0 : 1);
  }
}
function CustomWidget_ng_template_1_Template(rf, ctx) {
}
var _c2 = (a0, a1, a2) => ({
  $implicit: a0,
  schema: a1,
  ui: a2
});
function DateWidget_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-year-picker", 1);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_1_Template_nz_year_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r5.displayValue, $event) || (ctx_r5.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_1_Template_nz_year_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7._change($event));
    })("nzOnOpenChange", function DateWidget_Case_1_Template_nz_year_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8._openChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("nzId", ctx_r0.id)("nzDisabled", ctx_r0.disabled)("nzSize", ctx_r0.ui.size)("nzFormat", ctx_r0.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r0.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r0.i.allowClear)("ngClass", ctx_r0.ui.className)("nzDisabledDate", ctx_r0.ui.disabledDate)("nzLocale", ctx_r0.ui.locale)("nzPlaceHolder", ctx_r0.ui.placeholder)("nzPopupStyle", ctx_r0.ui.popupStyle)("nzDropdownClassName", ctx_r0.ui.dropdownClassName)("nzRenderExtraFooter", ctx_r0.ui.renderExtraFooter)("nzInputReadOnly", ctx_r0.ui.inputReadOnly)("nzInline", ctx_r0.ui.inline);
  }
}
function DateWidget_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-month-picker", 1);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_2_Template_nz_month_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r10);
      const ctx_r9 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r9.displayValue, $event) || (ctx_r9.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_2_Template_nz_month_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r10);
      const ctx_r11 = ɵɵnextContext();
      return ɵɵresetView(ctx_r11._change($event));
    })("nzOnOpenChange", function DateWidget_Case_2_Template_nz_month_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r10);
      const ctx_r12 = ɵɵnextContext();
      return ɵɵresetView(ctx_r12._openChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("nzId", ctx_r1.id)("nzDisabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("nzFormat", ctx_r1.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r1.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r1.i.allowClear)("ngClass", ctx_r1.ui.className)("nzDisabledDate", ctx_r1.ui.disabledDate)("nzLocale", ctx_r1.ui.locale)("nzPlaceHolder", ctx_r1.ui.placeholder)("nzPopupStyle", ctx_r1.ui.popupStyle)("nzDropdownClassName", ctx_r1.ui.dropdownClassName)("nzRenderExtraFooter", ctx_r1.ui.renderExtraFooter)("nzInputReadOnly", ctx_r1.ui.inputReadOnly)("nzInline", ctx_r1.ui.inline);
  }
}
function DateWidget_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-week-picker", 2);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_3_Template_nz_week_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r13 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r13.displayValue, $event) || (ctx_r13.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_3_Template_nz_week_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r15 = ɵɵnextContext();
      return ɵɵresetView(ctx_r15._change($event));
    })("nzOnOpenChange", function DateWidget_Case_3_Template_nz_week_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r16 = ɵɵnextContext();
      return ɵɵresetView(ctx_r16._openChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("nzId", ctx_r2.id)("nzDisabled", ctx_r2.disabled)("nzSize", ctx_r2.ui.size)("nzFormat", ctx_r2.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r2.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r2.i.allowClear)("ngClass", ctx_r2.ui.className)("nzDisabledDate", ctx_r2.ui.disabledDate)("nzLocale", ctx_r2.ui.locale)("nzPlaceHolder", ctx_r2.ui.placeholder)("nzPopupStyle", ctx_r2.ui.popupStyle)("nzDropdownClassName", ctx_r2.ui.dropdownClassName)("nzInputReadOnly", ctx_r2.ui.inputReadOnly)("nzInline", ctx_r2.ui.inline);
  }
}
function DateWidget_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-range-picker", 3);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_4_Template_nz_range_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r18);
      const ctx_r17 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r17.displayValue, $event) || (ctx_r17.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_4_Template_nz_range_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r18);
      const ctx_r19 = ɵɵnextContext();
      return ɵɵresetView(ctx_r19._change($event));
    })("nzOnOpenChange", function DateWidget_Case_4_Template_nz_range_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r18);
      const ctx_r20 = ɵɵnextContext();
      return ɵɵresetView(ctx_r20._openChange($event));
    })("nzOnOk", function DateWidget_Case_4_Template_nz_range_picker_nzOnOk_0_listener($event) {
      ɵɵrestoreView(_r18);
      const ctx_r21 = ɵɵnextContext();
      return ɵɵresetView(ctx_r21._ok($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("nzId", ctx_r3.id)("nzDisabled", ctx_r3.disabled)("nzSize", ctx_r3.ui.size)("nzFormat", ctx_r3.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r3.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r3.i.allowClear)("ngClass", ctx_r3.ui.className)("nzDisabledDate", ctx_r3.ui.disabledDate)("nzLocale", ctx_r3.ui.locale)("nzPlaceHolder", ctx_r3.ui.placeholder)("nzPopupStyle", ctx_r3.ui.popupStyle)("nzDropdownClassName", ctx_r3.ui.dropdownClassName)("nzDisabledTime", ctx_r3.ui.disabledTime)("nzRenderExtraFooter", ctx_r3.ui.renderExtraFooter)("nzRanges", ctx_r3.ui.ranges)("nzShowTime", ctx_r3.ui.showTime)("nzSeparator", ctx_r3.ui.separator)("nzShowWeekNumber", ctx_r3.ui.showWeekNumber || false)("nzMode", ctx_r3.ui.rangeMode)("nzInputReadOnly", ctx_r3.ui.inputReadOnly)("nzInline", ctx_r3.ui.inline);
  }
}
function DateWidget_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-date-picker", 4);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_5_Template_nz_date_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r23);
      const ctx_r22 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r22.displayValue, $event) || (ctx_r22.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_5_Template_nz_date_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r23);
      const ctx_r24 = ɵɵnextContext();
      return ɵɵresetView(ctx_r24._change($event));
    })("nzOnOpenChange", function DateWidget_Case_5_Template_nz_date_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r23);
      const ctx_r25 = ɵɵnextContext();
      return ɵɵresetView(ctx_r25._openChange($event));
    })("nzOnOk", function DateWidget_Case_5_Template_nz_date_picker_nzOnOk_0_listener($event) {
      ɵɵrestoreView(_r23);
      const ctx_r26 = ɵɵnextContext();
      return ɵɵresetView(ctx_r26._ok($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("nzId", ctx_r4.id)("nzDisabled", ctx_r4.disabled)("nzSize", ctx_r4.ui.size)("nzFormat", ctx_r4.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r4.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r4.i.allowClear)("ngClass", ctx_r4.ui.className)("nzDisabledDate", ctx_r4.ui.disabledDate)("nzLocale", ctx_r4.ui.locale)("nzPlaceHolder", ctx_r4.ui.placeholder)("nzPopupStyle", ctx_r4.ui.popupStyle)("nzDropdownClassName", ctx_r4.ui.dropdownClassName)("nzDisabledTime", ctx_r4.ui.disabledTime)("nzRenderExtraFooter", ctx_r4.ui.renderExtraFooter)("nzShowTime", ctx_r4.ui.showTime)("nzShowToday", ctx_r4.i.showToday)("nzShowWeekNumber", ctx_r4.ui.showWeekNumber || false)("nzInputReadOnly", ctx_r4.ui.inputReadOnly)("nzInline", ctx_r4.ui.inline);
  }
}
var _c3 = (a0) => ({
  "ant-input-number__hide-step": a0
});
function ObjectWidget_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r5.title);
  }
}
function ObjectWidget_ng_template_0_Conditional_1_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵelement(1, "sf-item", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r9 = ɵɵnextContext().$implicit;
    ɵɵproperty("nzSpan", i_r9.grid.span)("nzOffset", i_r9.grid.offset)("nzXs", i_r9.grid.xs)("nzSm", i_r9.grid.sm)("nzMd", i_r9.grid.md)("nzLg", i_r9.grid.lg)("nzXl", i_r9.grid.xl)("nzXXl", i_r9.grid.xxl);
    ɵɵadvance();
    ɵɵproperty("formProperty", i_r9.property)("fixed-label", i_r9.spanLabelFixed);
  }
}
function ObjectWidget_ng_template_0_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ObjectWidget_ng_template_0_Conditional_1_For_2_Conditional_0_Template, 2, 10, "div", 5);
  }
  if (rf & 2) {
    const i_r9 = ctx.$implicit;
    ɵɵconditional(0, i_r9.property.visible && i_r9.show ? 0 : -1);
  }
}
function ObjectWidget_ng_template_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵrepeaterCreate(1, ObjectWidget_ng_template_0_Conditional_1_For_2_Template, 1, 1, null, null, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵproperty("nzGutter", ctx_r6.grid.gutter);
    ɵɵadvance();
    ɵɵrepeater(ctx_r6.list);
  }
}
function ObjectWidget_ng_template_0_Conditional_2_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "sf-item", 6);
  }
  if (rf & 2) {
    const i_r17 = ɵɵnextContext().$implicit;
    ɵɵproperty("formProperty", i_r17.property)("fixed-label", i_r17.spanLabelFixed);
  }
}
function ObjectWidget_ng_template_0_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ObjectWidget_ng_template_0_Conditional_2_For_1_Conditional_0_Template, 1, 2, "sf-item", 6);
  }
  if (rf & 2) {
    const i_r17 = ctx.$implicit;
    ɵɵconditional(0, i_r17.property.visible && i_r17.show ? 0 : -1);
  }
}
function ObjectWidget_ng_template_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, ObjectWidget_ng_template_0_Conditional_2_For_1_Template, 1, 1, null, null, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext(2);
    ɵɵrepeater(ctx_r7.list);
  }
}
function ObjectWidget_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ObjectWidget_ng_template_0_Conditional_0_Template, 2, 1, "div", 2)(1, ObjectWidget_ng_template_0_Conditional_1_Template, 3, 1, "div", 3)(2, ObjectWidget_ng_template_0_Conditional_2_Template, 2, 0);
  }
  if (rf & 2) {
    const noTitle_r4 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(0, !noTitle_r4 && ctx_r0.title ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(1, ctx_r0.grid ? 1 : 2);
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "i", 13);
  }
  if (rf & 2) {
    const ctx_r27 = ɵɵnextContext(3);
    ɵɵproperty("nzType", ctx_r27.expand ? "down" : "up");
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "i", 15);
  }
  if (rf & 2) {
    const ctx_r29 = ɵɵnextContext(4);
    ɵɵproperty("nzTooltipTitle", ctx_r29.oh.text)("nzTooltipPlacement", ctx_r29.oh.placement)("nzTooltipTrigger", ctx_r29.oh.trigger)("nzTooltipColor", ctx_r29.oh.bgColor)("nzTooltipOverlayClassName", ctx_r29.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r29.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r29.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r29.oh.mouseLeaveDelay)("nzType", ctx_r29.oh.icon);
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtext(1);
    ɵɵtemplate(2, ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Conditional_2_Template, 1, 9, "i", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r28 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r28.ui.optional, " ");
    ɵɵadvance();
    ɵɵconditional(2, ctx_r28.oh ? 2 : -1);
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r31 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10);
    ɵɵlistener("click", function ObjectWidget_Conditional_2_ng_template_1_Template_div_click_0_listener() {
      ɵɵrestoreView(_r31);
      const ctx_r30 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r30.changeExpand());
    });
    ɵɵtemplate(1, ObjectWidget_Conditional_2_ng_template_1_Conditional_1_Template, 1, 1, "i", 11);
    ɵɵtext(2);
    ɵɵtemplate(3, ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Template, 3, 2, "span", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r24 = ɵɵnextContext(2);
    ɵɵclassProp("point", ctx_r24.showExpand);
    ɵɵadvance();
    ɵɵconditional(1, ctx_r24.showExpand ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r24.title, " ");
    ɵɵadvance();
    ɵɵconditional(3, ctx_r24.ui.optional || ctx_r24.oh ? 3 : -1);
  }
}
function ObjectWidget_Conditional_2_ng_template_3_Template(rf, ctx) {
}
var _c4 = () => [];
var _c5 = () => ({
  $implicit: true
});
function ObjectWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-card", 7);
    ɵɵtemplate(1, ObjectWidget_Conditional_2_ng_template_1_Template, 4, 5, "ng-template", null, 8, ɵɵtemplateRefExtractor)(3, ObjectWidget_Conditional_2_ng_template_3_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const _r25 = ɵɵreference(2);
    const ctx_r2 = ɵɵnextContext();
    const _r1 = ɵɵreference(1);
    ɵɵclassProp("sf__object-card-fold", !ctx_r2.expand);
    ɵɵproperty("nzTitle", _r25)("nzExtra", ctx_r2.ui.cardExtra)("nzSize", ctx_r2.ui.cardSize || "small")("nzActions", ctx_r2.ui.cardActions || ɵɵpureFunction0(11, _c4))("nzBodyStyle", ctx_r2.ui.cardBodyStyle)("nzBordered", ctx_r2.ui.cardBordered || true)("nzBorderless", ctx_r2.ui.cardBorderless || false);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", _r1)("ngTemplateOutletContext", ɵɵpureFunction0(12, _c5));
  }
}
function ObjectWidget_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function ObjectWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ObjectWidget_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r1 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", _r1);
  }
}
function RadioWidget_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 2);
    ɵɵelement(1, "span", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r3 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("nzValue", option_r3.value)("nzDisabled", ctx_r2.disabled || option_r3.disabled);
    ɵɵadvance();
    ɵɵproperty("innerHTML", option_r3.label, ɵɵsanitizeHtml);
  }
}
function RadioWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, RadioWidget_Conditional_2_For_1_Template, 2, 3, "label", 2, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵrepeater(ctx_r0.data);
  }
}
function RadioWidget_Conditional_3_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 4);
    ɵɵelement(1, "span", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r9 = ctx.$implicit;
    const ctx_r8 = ɵɵnextContext(2);
    ɵɵproperty("nzValue", option_r9.value)("nzDisabled", ctx_r8.disabled || option_r9.disabled);
    ɵɵadvance();
    ɵɵproperty("innerHTML", option_r9.label, ɵɵsanitizeHtml);
  }
}
function RadioWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, RadioWidget_Conditional_3_For_1_Template, 2, 3, "label", 4, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵrepeater(ctx_r1.data);
  }
}
function SelectWidget_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-option", 3);
  }
  if (rf & 2) {
    const o_r4 = ctx.$implicit;
    ɵɵproperty("nzLabel", o_r4.label)("nzValue", o_r4.value)("nzHide", o_r4.hide)("nzDisabled", o_r4.disabled);
  }
}
function SelectWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, SelectWidget_Conditional_2_For_1_Template, 1, 4, "nz-option", 3, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵrepeater(ctx_r0.data);
  }
}
function SelectWidget_Conditional_3_For_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-option", 5);
  }
  if (rf & 2) {
    const o_r16 = ctx.$implicit;
    ɵɵproperty("nzLabel", o_r16.label)("nzValue", o_r16.value)("nzDisabled", o_r16.disabled)("nzHide", o_r16.hide);
  }
}
function SelectWidget_Conditional_3_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-option-group", 4);
    ɵɵrepeaterCreate(1, SelectWidget_Conditional_3_For_1_For_2_Template, 1, 4, "nz-option", 5, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r10 = ctx.$implicit;
    ɵɵproperty("nzLabel", i_r10.label);
    ɵɵadvance();
    ɵɵrepeater(i_r10.children);
  }
}
function SelectWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, SelectWidget_Conditional_3_For_1_Template, 3, 1, "nz-option-group", 4, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵrepeater(ctx_r1.data);
  }
}
function SelectWidget_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-option", 2);
    ɵɵelement(1, "i", 6);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.ui.searchLoadingText, " ");
  }
}
function StringWidget_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 3);
    ɵɵlistener("ngModelChange", function StringWidget_ng_template_1_Template_input_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.change($event));
    })("keyup.enter", function StringWidget_ng_template_1_Template_input_keyup_enter_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.enter($event));
    })("focus", function StringWidget_ng_template_1_Template_input_focus_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.focus($event));
    })("blur", function StringWidget_ng_template_1_Template_input_blur_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.blur($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r0.disabled)("nzSize", ctx_r0.ui.size)("nzBorderless", ctx_r0.ui.borderless)("ngModel", ctx_r0.value);
    ɵɵattribute("id", ctx_r0.id)("disabled", ctx_r0.disabled)("maxLength", ctx_r0.schema.maxLength || null)("type", ctx_r0.ui.type || "text")("placeholder", ctx_r0.ui.placeholder)("autocomplete", ctx_r0.ui.autocomplete)("autoFocus", ctx_r0.ui.autofocus);
  }
}
function StringWidget_Conditional_3_ng_template_1_Template(rf, ctx) {
}
function StringWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-input-group", 2);
    ɵɵtemplate(1, StringWidget_Conditional_3_ng_template_1_Template, 0, 0, "ng-template", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const _r1 = ɵɵreference(2);
    ɵɵproperty("nzAddOnBefore", ctx_r2.ui.addOnBefore)("nzAddOnAfter", ctx_r2.ui.addOnAfter)("nzAddOnBeforeIcon", ctx_r2.ui.addOnBeforeIcon)("nzAddOnAfterIcon", ctx_r2.ui.addOnAfterIcon)("nzPrefix", ctx_r2.ui.prefix)("nzPrefixIcon", ctx_r2.ui.prefixIcon)("nzSuffix", ctx_r2.ui.suffix)("nzSuffixIcon", ctx_r2.ui.suffixIcon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r1);
  }
}
function StringWidget_Conditional_4_ng_template_0_Template(rf, ctx) {
}
function StringWidget_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, StringWidget_Conditional_4_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r1 = ɵɵreference(2);
    ɵɵproperty("ngTemplateOutlet", _r1);
  }
}
function TextWidget_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r0.text, ɵɵsanitizeHtml);
  }
}
function TextWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("innerText", ctx_r1.text);
  }
}
function TextareaWidget_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "textarea", 3);
    ɵɵlistener("ngModelChange", function TextareaWidget_ng_template_1_Template_textarea_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.change($event));
    })("focus", function TextareaWidget_ng_template_1_Template_textarea_focus_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.focus($event));
    })("blur", function TextareaWidget_ng_template_1_Template_textarea_blur_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.blur($event));
    });
    ɵɵtext(1, "      ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r0.disabled)("nzSize", ctx_r0.ui.size)("ngModel", ctx_r0.value)("nzAutosize", ctx_r0.autosize)("nzBorderless", ctx_r0.ui.borderless);
    ɵɵattribute("id", ctx_r0.id)("disabled", ctx_r0.disabled)("maxLength", ctx_r0.schema.maxLength || null)("placeholder", ctx_r0.ui.placeholder);
  }
}
function TextareaWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-textarea-count", 2)(1, "textarea", 3);
    ɵɵlistener("ngModelChange", function TextareaWidget_Conditional_3_Template_textarea_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.change($event));
    })("focus", function TextareaWidget_Conditional_3_Template_textarea_focus_1_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.focus($event));
    })("blur", function TextareaWidget_Conditional_3_Template_textarea_blur_1_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r11 = ɵɵnextContext();
      return ɵɵresetView(ctx_r11.blur($event));
    });
    ɵɵtext(2, "        ");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("nzMaxCharacterCount", ctx_r2.ui.maxCharacterCount)("nzComputeCharacterCount", ctx_r2.ui.computeCharacterCount);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r2.disabled)("nzSize", ctx_r2.ui.size)("ngModel", ctx_r2.value)("nzAutosize", ctx_r2.autosize)("nzBorderless", ctx_r2.ui.borderless);
    ɵɵattribute("id", ctx_r2.id)("disabled", ctx_r2.disabled)("maxLength", ctx_r2.schema.maxLength || null)("placeholder", ctx_r2.ui.placeholder);
  }
}
function TextareaWidget_Conditional_4_ng_template_0_Template(rf, ctx) {
}
function TextareaWidget_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextareaWidget_Conditional_4_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r1 = ɵɵreference(2);
    ɵɵproperty("ngTemplateOutlet", _r1);
  }
}
var SF_DEFAULT_CONFIG = {
  formatMap: {
    "date-time": {
      widget: "date",
      showTime: true,
      format: `yyyy-MM-dd'T'HH:mm:ss.SSSxxx`
    },
    date: {
      widget: "date",
      format: "yyyy-MM-dd"
    },
    "full-date": {
      widget: "date",
      format: "yyyy-MM-dd"
    },
    time: {
      widget: "time",
      format: "HH:mm:ss.SSSxxx"
    },
    "full-time": {
      widget: "time"
    },
    week: {
      widget: "date",
      mode: "week",
      format: "yyyy-ww"
    },
    month: {
      widget: "date",
      mode: "month",
      format: "yyyy-MM"
    },
    uri: {
      widget: "upload"
    },
    email: {
      widget: "autocomplete",
      type: "email"
    },
    color: {
      widget: "string",
      type: "color"
    },
    "": {
      widget: "string"
    }
  },
  ingoreKeywords: ["type", "enum"],
  liveValidate: true,
  autocomplete: null,
  firstVisual: false,
  onlyVisual: false,
  errors: {},
  ui: {},
  button: {
    submit_type: "primary",
    reset_type: "default"
  },
  uiDateStringFormat: "yyyy-MM-dd HH:mm:ss",
  uiDateNumberFormat: "T",
  uiTimeStringFormat: "HH:mm:ss",
  uiTimeNumberFormat: "T",
  uiEmailSuffixes: ["qq.com", "163.com", "gmail.com", "126.com", "aliyun.com"],
  delay: false
};
function mergeConfig(srv) {
  return srv.merge("sf", SF_DEFAULT_CONFIG);
}
var SF_SEQ = "/";
function isBlank(o) {
  return o == null;
}
function toBool(value, defaultValue) {
  return value == null ? defaultValue : `${value}` !== "false";
}
function di(ui, ...args) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (ui.debug) {
      console.warn(...args);
    }
  }
}
function findSchemaDefinition($ref, definitions) {
  const match = /^#\/definitions\/(.*)$/.exec($ref);
  if (match && match[1]) {
    const parts = match[1].split(SF_SEQ);
    let current = definitions;
    for (let part of parts) {
      part = part.replace(/~1/g, SF_SEQ).replace(/~0/g, "~");
      if (current.hasOwnProperty(part)) {
        current = current[part];
      } else {
        throw new Error(`Could not find a definition for ${$ref}.`);
      }
    }
    return current;
  }
  throw new Error(`Could not find a definition for ${$ref}.`);
}
function retrieveSchema(schema, definitions = {}) {
  if (schema.hasOwnProperty("$ref")) {
    const $refSchema = findSchemaDefinition(schema.$ref, definitions);
    const _a = schema, {
      $ref
    } = _a, localSchema = __objRest(_a, [
      "$ref"
    ]);
    return retrieveSchema(__spreadValues(__spreadValues({}, $refSchema), localSchema), definitions);
  }
  return schema;
}
function resolveIfSchema(_schema, _ui) {
  const fn = (schema, ui) => {
    resolveIf(schema, ui);
    Object.keys(schema.properties).forEach((key) => {
      const property = schema.properties[key];
      const uiKey = `$${key}`;
      if (property.items) {
        fn(property.items, ui[uiKey].$items);
      }
      if (property.properties) {
        fn(property, ui[uiKey]);
      }
    });
  };
  fn(_schema, _ui);
}
function resolveIf(schema, ui) {
  if (!(schema.hasOwnProperty("if") && schema.hasOwnProperty("then")))
    return null;
  if (!schema.if.properties)
    throw new Error(`if: does not contain 'properties'`);
  const allKeys = Object.keys(schema.properties);
  const ifKeys = Object.keys(schema.if.properties);
  detectKey(allKeys, ifKeys);
  detectKey(allKeys, schema.then.required);
  schema.required = schema.required.concat(schema.then.required);
  const hasElse = schema.hasOwnProperty("else");
  if (hasElse) {
    detectKey(allKeys, schema.else.required);
    schema.required = schema.required.concat(schema.else.required);
  }
  const visibleIf = {};
  const visibleElse = {};
  ifKeys.forEach((key) => {
    const cond = schema.if.properties[key].enum;
    visibleIf[key] = cond;
    if (hasElse)
      visibleElse[key] = (value) => !cond.includes(value);
  });
  schema.then.required.forEach((key) => ui[`$${key}`].visibleIf = visibleIf);
  if (hasElse) {
    schema.else.required.forEach((key) => ui[`$${key}`].visibleIf = visibleElse);
  }
  return schema;
}
function detectKey(keys, detectKeys) {
  detectKeys.forEach((key) => {
    if (!keys.includes(key)) {
      throw new Error(`if: properties does not contain '${key}'`);
    }
  });
}
function orderProperties(properties, order) {
  if (!Array.isArray(order))
    return properties;
  const arrayToHash = (arr) => arr.reduce((prev, curr) => {
    prev[curr] = true;
    return prev;
  }, {});
  const errorPropList = (arr) => `property [${arr.join(`', '`)}]`;
  const propertyHash = arrayToHash(properties);
  const orderHash = arrayToHash(order);
  const extraneous = order.filter((prop) => prop !== "*" && !propertyHash[prop]);
  if (extraneous.length) {
    throw new Error(`ui schema order list contains extraneous ${errorPropList(extraneous)}`);
  }
  const rest = properties.filter((prop) => !orderHash[prop]);
  const restIndex = order.indexOf("*");
  if (restIndex === -1) {
    if (rest.length) {
      throw new Error(`ui schema order list does not contain ${errorPropList(rest)}`);
    }
    return order;
  }
  if (restIndex !== order.lastIndexOf("*")) {
    throw new Error("ui schema order list contains more than one wildcard item");
  }
  const complete = [...order];
  complete.splice(restIndex, 1, ...rest);
  return complete;
}
function getEnum(list, formData, readOnly) {
  if (isBlank(list) || !Array.isArray(list) || list.length === 0)
    return [];
  if (typeof list[0] !== "object") {
    list = list.map((item) => {
      return {
        label: item,
        value: item
      };
    });
  }
  if (formData) {
    if (!Array.isArray(formData))
      formData = [formData];
    list.forEach((item) => {
      if (~formData.indexOf(item.value))
        item.checked = true;
    });
  }
  if (readOnly) {
    list.forEach((item) => item.disabled = true);
  }
  return list;
}
function getCopyEnum(list, formData, readOnly) {
  return getEnum(deepCopy(list || []), formData, readOnly);
}
function getData(schema, ui, formData, asyncArgs) {
  if (typeof ui.asyncData === "function") {
    return ui.asyncData(asyncArgs).pipe(map((list) => getEnum(list, formData, schema.readOnly)));
  }
  return of(getCopyEnum(schema.enum, formData, schema.readOnly));
}
function isDateFns(srv) {
  if (!srv)
    return false;
  const data = srv.getDateLocale();
  return data != null && !!data.formatDistance;
}
var FormProperty = class {
  constructor(injector, schemaValidatorFactory, schema, ui, formData, parent, path, _options) {
    this.injector = injector;
    this._options = _options;
    this._errors = null;
    this._valueChanges = new BehaviorSubject({
      path: null,
      pathValue: null,
      value: null
    });
    this._errorsChanges = new BehaviorSubject(null);
    this._visible = true;
    this._visibilityChanges = new BehaviorSubject(true);
    this._objErrors = {};
    this._value = null;
    this.schema = schema;
    this.ui = ui;
    this.schemaValidator = schemaValidatorFactory.createValidatorFn(schema, {
      ingoreKeywords: this.ui.ingoreKeywords,
      debug: ui.debug
    });
    this.formData = formData || schema.default;
    this._parent = parent;
    if (parent) {
      this._root = parent.root;
    } else {
      this._root = this;
    }
    this.path = path;
  }
  get valueChanges() {
    return this._valueChanges;
  }
  get errorsChanges() {
    return this._errorsChanges;
  }
  get type() {
    return this.schema.type;
  }
  get parent() {
    return this._parent;
  }
  get root() {
    return this._root;
  }
  get value() {
    return this._value;
  }
  get errors() {
    return this._errors;
  }
  get visible() {
    return this._visible;
  }
  get valid() {
    return this._errors === null || this._errors.length === 0;
  }
  get options() {
    return this._options;
  }
  cd(onlySelf = false) {
    this.widget?.detectChanges(onlySelf);
  }
  /**
   * 更新值且校验数据
   */
  updateValueAndValidity(options) {
    options = __spreadValues({
      onlySelf: false,
      emitValidator: true,
      emitValueEvent: true,
      updatePath: "",
      updateValue: null
    }, options);
    this._updateValue();
    if (options.emitValueEvent) {
      options.updatePath = options.updatePath || this.path;
      options.updateValue = options.updateValue == null ? this.value : options.updateValue;
      this.valueChanges.next({
        value: this.value,
        path: options.updatePath,
        pathValue: options.updateValue
      });
    }
    if (options.emitValidator && this.ui.liveValidate === true) {
      this._runValidation();
    }
    if (this.parent && !options.onlySelf) {
      this.parent.updateValueAndValidity(__spreadProps(__spreadValues({}, options), {
        emitValidator: false
      }));
    }
  }
  /** 根据路径搜索表单属性 */
  searchProperty(path) {
    let prop = this;
    let base = null;
    let result = null;
    if (path[0] === SF_SEQ) {
      base = this.findRoot();
      result = base.getProperty(path.substring(1));
    } else {
      while (result === null && prop.parent !== null) {
        prop = base = prop.parent;
        result = base.getProperty(path);
      }
    }
    return result;
  }
  /** 查找根表单属性 */
  findRoot() {
    let property = this;
    while (property.parent !== null) {
      property = property.parent;
    }
    return property;
  }
  // #region process errors
  isEmptyData(value) {
    if (isBlank(value))
      return true;
    switch (this.type) {
      case "string":
        return `${value}`.length === 0;
    }
    return false;
  }
  /**
   * @internal
   */
  _runValidation() {
    let errors;
    const isEmpty = this.isEmptyData(this._value);
    if (isEmpty && this.ui._required) {
      errors = [{
        keyword: "required"
      }];
    } else if (isEmpty) {
      errors = [];
    } else {
      errors = this.schemaValidator(this._value) || [];
    }
    const customValidator = this.ui.validator;
    if (typeof customValidator === "function") {
      const customErrors = customValidator(this.value, this, this.findRoot());
      if (customErrors instanceof Observable) {
        customErrors.subscribe((res) => {
          this.setCustomErrors(errors, res);
          this.cd(false);
        });
        return;
      }
      this.setCustomErrors(errors, customErrors);
      return;
    }
    this._errors = errors;
    this.setErrors(this._errors);
  }
  setCustomErrors(errors, list) {
    const hasCustomError = Array.isArray(list) && list.length > 0;
    if (hasCustomError) {
      list.forEach((err) => {
        if (!err.message) {
          throw new Error(`The custom validator must contain a 'message' attribute to viewed error text`);
        }
        err.keyword = null;
      });
    }
    this._errors = hasCustomError ? errors.concat(...list) : errors;
    this.setErrors(this._errors);
  }
  /**
   * Set the current error message
   *
   * 设置当前错误消息
   *
   * @param emitFormat 若提供的消息带有 `{xx}` 会自动根据参数进行转化，包含自定义函数
   *
   * @example
   *
   * this.sf.getProperty('/name')?.setErrors({ keyword: 'required' });
   * this.sf.getProperty('/name')?.setErrors({ message: 'Please input your username!' });
   * this.sf.getProperty('/name')?.setErrors(); // Clean error
   */
  setErrors(errors = [], emitFormat = true) {
    let arrErrs = Array.isArray(errors) ? errors : [errors];
    if (emitFormat && arrErrs && !this.ui.onlyVisual) {
      const l = this.widget && this.widget.l.error || {};
      arrErrs = arrErrs.map((err) => {
        let message = err.keyword == null && err.message ? err.message : (this.ui.errors || {})[err.keyword] || this._options.errors[err.keyword] || l[err.keyword] || ``;
        if (message && typeof message === "function") {
          message = message(err);
        }
        if (message) {
          if (~message.indexOf("{") && err.params) {
            message = message.replace(/{([\.a-zA-Z0-9]+)}/g, (_v, key) => err.params[key] || "");
          }
          err.message = message;
        }
        return err;
      });
    }
    this._errors = arrErrs;
    this._errorsChanges.next(arrErrs);
    if (this._parent) {
      this._parent.setParentAndPlatErrors(arrErrs, this.path);
    }
  }
  setParentAndPlatErrors(errors, path) {
    this._objErrors[path] = errors;
    const platErrors = [];
    Object.keys(this._objErrors).forEach((p) => {
      const property = this.searchProperty(p);
      if (property && !property.visible)
        return;
      platErrors.push(...this._objErrors[p]);
    });
    this.setErrors(platErrors, false);
  }
  // #endregion
  // #region condition
  /**
   * Set the hide or display of widget
   * 设置小部件的隐藏或显示
   */
  setVisible(visible) {
    this._visible = visible;
    this._visibilityChanges.next(visible);
    if (visible) {
      this.injector.get(NgZone).onStable.pipe(take(1)).subscribe(() => {
        this.resetValue(this.value, true);
      });
    }
    return this;
  }
  _bindVisibility() {
    const visibleIf = this.ui.visibleIf;
    if (typeof visibleIf === "object" && Object.keys(visibleIf).length === 0) {
      this.setVisible(false);
    } else if (visibleIf != null) {
      const propertiesBinding = [];
      for (const dependencyPath in visibleIf) {
        if (visibleIf.hasOwnProperty(dependencyPath)) {
          const property = this.searchProperty(dependencyPath);
          if (property) {
            const valueCheck = property.valueChanges.pipe(map((res) => {
              const vi = visibleIf[dependencyPath];
              if (typeof vi === "function") {
                const viFnRes = vi(res.value, property);
                if (typeof viFnRes === "object") {
                  const fixViFnRes = __spreadValues({
                    show: false,
                    required: false
                  }, viFnRes);
                  const parentRequired = this.parent?.schema.required;
                  if (parentRequired && this.propertyId) {
                    const idx = parentRequired.findIndex((w) => w === this.propertyId);
                    if (fixViFnRes.required) {
                      if (idx === -1)
                        parentRequired.push(this.propertyId);
                    } else {
                      if (idx !== -1)
                        parentRequired.splice(idx, 1);
                    }
                    this.ui._required = fixViFnRes.required;
                  }
                  return fixViFnRes.show;
                }
                return viFnRes;
              }
              if (vi.indexOf("$ANY$") !== -1) {
                return res.value && res.value.length > 0;
              } else {
                return vi.indexOf(res.value) !== -1;
              }
            }));
            const visibilityCheck = property._visibilityChanges;
            const and = combineLatest([valueCheck, visibilityCheck]).pipe(map((results) => results[0] && results[1]));
            propertiesBinding.push(and);
          } else {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              console.warn(`Can't find property ${dependencyPath} for visibility check of ${this.path}`);
            }
          }
        }
      }
      combineLatest(propertiesBinding).pipe(map((values) => this.ui.visibleIfLogical === "and" ? values.every((v) => v) : values.some((v) => v)), distinctUntilChanged()).subscribe((visible) => this.setVisible(visible));
    }
  }
  // #endregion
  updateFeedback(status = "") {
    this.ui.feedback = status;
    this.widget?.injector.get(NzFormStatusService).formStatusChanges.next({
      status,
      hasFeedback: !!status
    });
    this.cd(true);
  }
};
var PropertyGroup = class _PropertyGroup extends FormProperty {
  constructor() {
    super(...arguments);
    this.properties = null;
  }
  getProperty(path) {
    const subPathIdx = path.indexOf(SF_SEQ);
    const propertyId = subPathIdx !== -1 ? path.substring(0, subPathIdx) : path;
    let property = this.properties[propertyId];
    if (property !== null && subPathIdx !== -1 && property instanceof _PropertyGroup) {
      const subPath = path.substring(subPathIdx + 1);
      property = property.getProperty(subPath);
    }
    return property;
  }
  forEachChild(fn) {
    for (const propertyId in this.properties) {
      if (this.properties.hasOwnProperty(propertyId)) {
        const property = this.properties[propertyId];
        fn(property, propertyId);
      }
    }
  }
  forEachChildRecursive(fn) {
    this.forEachChild((child) => {
      fn(child);
      if (child instanceof _PropertyGroup) {
        child.forEachChildRecursive(fn);
      }
    });
  }
  _bindVisibility() {
    super._bindVisibility();
    this._bindVisibilityRecursive();
  }
  _bindVisibilityRecursive() {
    this.forEachChildRecursive((property) => {
      property._bindVisibility();
    });
  }
  isRoot() {
    return this === this.root;
  }
};
var ObjectProperty = class extends PropertyGroup {
  get propertiesId() {
    return this._propertiesId;
  }
  constructor(injector, formPropertyFactory, schemaValidatorFactory, schema, ui, formData, parent, path, options) {
    super(injector, schemaValidatorFactory, schema, ui, formData, parent, path, options);
    this.formPropertyFactory = formPropertyFactory;
    this._propertiesId = [];
    this.createProperties();
  }
  createProperties() {
    this.properties = {};
    this._propertiesId = [];
    let orderedProperties;
    try {
      orderedProperties = orderProperties(Object.keys(this.schema.properties), this.ui.order);
    } catch (e) {
      console.error(`Invalid ${this.schema.title || "root"} object field configuration:`, e);
    }
    orderedProperties.forEach((propertyId) => {
      this.properties[propertyId] = this.formPropertyFactory.createProperty(this.schema.properties[propertyId], this.ui[`$${propertyId}`], (this.formData || {})[propertyId], this, propertyId);
      this._propertiesId.push(propertyId);
    });
  }
  setValue(value, onlySelf) {
    const properties = this.properties;
    for (const propertyId in value) {
      if (value.hasOwnProperty(propertyId) && properties[propertyId]) {
        properties[propertyId].setValue(value[propertyId], true);
      }
    }
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  resetValue(value, onlySelf) {
    value = value || this.schema.default || {};
    const properties = this.properties;
    for (const propertyId in this.schema.properties) {
      if (this.schema.properties.hasOwnProperty(propertyId)) {
        properties[propertyId].resetValue(value[propertyId], true);
      }
    }
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  _hasValue() {
    return this.value != null && !!Object.keys(this.value).length;
  }
  _updateValue() {
    const value = {};
    this.forEachChild((property, propertyId) => {
      if (property.visible && property._hasValue()) {
        value[propertyId] = property.value;
      }
    });
    this._value = value;
  }
};
var ArrayProperty = class extends PropertyGroup {
  constructor(injector, formPropertyFactory, schemaValidatorFactory, schema, ui, formData, parent, path, options) {
    super(injector, schemaValidatorFactory, schema, ui, formData, parent, path, options);
    this.formPropertyFactory = formPropertyFactory;
    this.properties = [];
  }
  getProperty(path) {
    const subPathIdx = path.indexOf(SF_SEQ);
    const pos = +(subPathIdx !== -1 ? path.substring(0, subPathIdx) : path);
    const list = this.properties;
    if (isNaN(pos) || pos >= list.length) {
      return void 0;
    }
    const subPath = path.substring(subPathIdx + 1);
    return list[pos].getProperty(subPath);
  }
  setValue(value, onlySelf) {
    this.properties = [];
    this.clearErrors();
    this.resetProperties(value);
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  resetValue(value, onlySelf) {
    this._value = value || this.schema.default || [];
    this.setValue(this._value, onlySelf);
  }
  _hasValue() {
    return true;
  }
  _updateValue() {
    const value = [];
    this.forEachChild((property) => {
      if (property.visible) {
        value.push(__spreadValues(__spreadValues({}, this.widget?.cleanValue ? null : property.formData), property.value));
      }
    });
    this._value = value;
  }
  addProperty(formData) {
    const newProperty = this.formPropertyFactory.createProperty(deepCopy(this.schema.items), deepCopy(this.ui.$items), formData, this);
    this.properties.push(newProperty);
    return newProperty;
  }
  resetProperties(formDatas) {
    for (const item of formDatas) {
      const property = this.addProperty(item);
      property.resetValue(item, true);
    }
  }
  clearErrors(property) {
    (property || this)._objErrors = {};
  }
  // #region actions
  add(formData) {
    const newProperty = this.addProperty(formData);
    newProperty.resetValue(formData, false);
    return newProperty;
  }
  remove(index) {
    const list = this.properties;
    this.clearErrors();
    list.splice(index, 1);
    list.forEach((property, idx) => {
      property.path = [property.parent.path, idx].join(SF_SEQ);
      this.clearErrors(property);
      if (property instanceof ObjectProperty) {
        property.forEachChild((p) => {
          p.updateValueAndValidity({
            emitValueEvent: false
          });
        });
      }
    });
    if (list.length === 0) {
      this.updateValueAndValidity();
    }
  }
};
var AtomicProperty = class extends FormProperty {
  setValue(value, onlySelf) {
    this._value = value;
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  resetValue(value, onlySelf) {
    if (value == null) {
      value = this.schema.default !== void 0 ? this.schema.default : this.fallbackValue();
    }
    this._value = value;
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
    if (this.widget) {
      this.widget.reset(value);
      this.cd(onlySelf);
    }
  }
  _hasValue() {
    return this.fallbackValue() !== this.value;
  }
  _updateValue() {
  }
};
var BooleanProperty = class extends AtomicProperty {
  fallbackValue() {
    return null;
  }
};
var NumberProperty = class extends AtomicProperty {
  fallbackValue() {
    return null;
  }
  setValue(value, onlySelf) {
    if (typeof value === "string") {
      if (value.length) {
        value = value.indexOf(".") > -1 ? parseFloat(value) : parseInt(value, 10);
      } else {
        value = void 0;
      }
    }
    this._value = value;
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
};
var StringProperty = class extends AtomicProperty {
  fallbackValue() {
    return null;
  }
  setValue(value, onlySelf) {
    this._value = value == null ? "" : value;
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
};
var FormPropertyFactory = class {
  constructor(injector, schemaValidatorFactory, cogSrv) {
    this.injector = injector;
    this.schemaValidatorFactory = schemaValidatorFactory;
    this.options = mergeConfig(cogSrv);
  }
  createProperty(schema, ui, formData, parent = null, propertyId) {
    let newProperty = null;
    let path = "";
    if (parent) {
      path += parent.path;
      if (parent.parent !== null) {
        path += SF_SEQ;
      }
      switch (parent.type) {
        case "object":
          path += propertyId;
          break;
        case "array":
          path += parent.properties.length;
          break;
        default:
          throw new Error(`Instanciation of a FormProperty with an unknown parent type: ${parent.type}`);
      }
    } else {
      path = SF_SEQ;
    }
    if (schema.$ref) {
      const refSchema = retrieveSchema(schema, parent.root.schema.definitions);
      newProperty = this.createProperty(refSchema, ui, formData, parent, path);
    } else {
      if (propertyId && parent.schema.required.indexOf(propertyId.split(SF_SEQ).pop()) !== -1 || ui.showRequired === true) {
        ui._required = true;
      }
      if (schema.title == null) {
        schema.title = propertyId;
      }
      if ((schema.type === "string" || schema.type === "number") && !schema.format && !ui.format) {
        if (ui.widget === "date")
          ui._format = schema.type === "string" ? this.options.uiDateStringFormat : this.options.uiDateNumberFormat;
        else if (ui.widget === "time")
          ui._format = schema.type === "string" ? this.options.uiTimeStringFormat : this.options.uiTimeNumberFormat;
      } else {
        ui._format = ui.format;
      }
      switch (schema.type) {
        case "integer":
        case "number":
          newProperty = new NumberProperty(this.injector, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "string":
          newProperty = new StringProperty(this.injector, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "boolean":
          newProperty = new BooleanProperty(this.injector, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "object":
          newProperty = new ObjectProperty(this.injector, this, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "array":
          newProperty = new ArrayProperty(this.injector, this, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        default:
          throw new TypeError(`Undefined type ${schema.type}`);
      }
    }
    newProperty.propertyId = propertyId;
    if (newProperty instanceof PropertyGroup) {
      this.initializeRoot(newProperty);
    }
    return newProperty;
  }
  initializeRoot(rootProperty) {
    rootProperty._bindVisibility();
  }
};
var TerminatorService = class {
  constructor() {
    this.onDestroy = new Subject();
  }
  destroy() {
    this.onDestroy.next(true);
  }
};
var _SchemaValidatorFactory = class _SchemaValidatorFactory {
};
_SchemaValidatorFactory.ɵfac = function SchemaValidatorFactory_Factory(t) {
  return new (t || _SchemaValidatorFactory)();
};
_SchemaValidatorFactory.ɵprov = ɵɵdefineInjectable({
  token: _SchemaValidatorFactory,
  factory: _SchemaValidatorFactory.ɵfac
});
var SchemaValidatorFactory = _SchemaValidatorFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchemaValidatorFactory, [{
    type: Injectable
  }], null, null);
})();
var _AjvSchemaValidatorFactory = class _AjvSchemaValidatorFactory extends SchemaValidatorFactory {
  constructor() {
    super();
    this.ngZone = inject(NgZone);
    this.cogSrv = inject(AlainConfigService);
    if (!(typeof document === "object" && !!document)) {
      return;
    }
    this.options = mergeConfig(this.cogSrv);
    const customOptions = this.options.ajv || {};
    this.ngZone.runOutsideAngular(() => {
      this.ajv = new import_ajv.default(__spreadProps(__spreadValues({
        allErrors: true,
        loopEnum: 50
      }, customOptions), {
        formats: __spreadValues({
          "data-url": /^data:([a-z]+\/[a-z0-9-+.]+)?;name=(.*);base64,(.*)$/,
          color: REGEX.color,
          mobile: REGEX.mobile,
          "id-card": REGEX.idCard
        }, customOptions.formats)
      }));
      (0, import_ajv_formats.default)(this.ajv);
    });
  }
  createValidatorFn(schema, extraOptions) {
    const ingoreKeywords = [...this.options.ingoreKeywords, ...extraOptions.ingoreKeywords || []];
    return (value) => {
      try {
        this.ngZone.runOutsideAngular(() => this.ajv.validate(schema, value));
      } catch (e) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (extraOptions.debug) {
            console.warn(e);
          }
        }
      }
      let errors = this.ajv.errors;
      if (this.options && ingoreKeywords && errors) {
        errors = errors.filter((w) => ingoreKeywords.indexOf(w.keyword) === -1);
      }
      return errors;
    };
  }
};
_AjvSchemaValidatorFactory.ɵfac = function AjvSchemaValidatorFactory_Factory(t) {
  return new (t || _AjvSchemaValidatorFactory)();
};
_AjvSchemaValidatorFactory.ɵprov = ɵɵdefineInjectable({
  token: _AjvSchemaValidatorFactory,
  factory: _AjvSchemaValidatorFactory.ɵfac
});
var AjvSchemaValidatorFactory = _AjvSchemaValidatorFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AjvSchemaValidatorFactory, [{
    type: Injectable
  }], () => [], null);
})();
var WidgetRegistry = class {
  constructor() {
    this._widgets = {};
  }
  get widgets() {
    return this._widgets;
  }
  setDefault(widget) {
    this.defaultWidget = widget;
  }
  register(type, widget) {
    this._widgets[type] = widget;
  }
  has(type) {
    return this._widgets.hasOwnProperty(type);
  }
  getType(type) {
    if (this.has(type)) {
      return this._widgets[type];
    }
    return this.defaultWidget;
  }
};
var _WidgetFactory = class _WidgetFactory {
  constructor() {
    this.registry = inject(WidgetRegistry);
  }
  createWidget(container, type) {
    if (!this.registry.has(type)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        console.warn(`No widget for type "${type}"`);
      }
    }
    const componentClass = this.registry.getType(type);
    return container.createComponent(componentClass);
  }
};
_WidgetFactory.ɵfac = function WidgetFactory_Factory(t) {
  return new (t || _WidgetFactory)();
};
_WidgetFactory.ɵprov = ɵɵdefineInjectable({
  token: _WidgetFactory,
  factory: _WidgetFactory.ɵfac
});
var WidgetFactory = _WidgetFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WidgetFactory, [{
    type: Injectable
  }], null, null);
})();
var nextUniqueId = 0;
var _SFItemComponent = class _SFItemComponent {
  constructor() {
    this.widgetFactory = inject(WidgetFactory);
    this.terminator = inject(TerminatorService);
    this.destroy$ = new Subject();
    this.widget = null;
    this.footer = null;
  }
  onWidgetInstanciated(widget) {
    this.widget = widget;
    const id = `_sf-${nextUniqueId++}`;
    const ui = this.formProperty.ui;
    this.widget.formProperty = this.formProperty;
    this.widget.schema = this.formProperty.schema;
    this.widget.ui = ui;
    this.widget.id = id;
    this.formProperty.widget = widget;
  }
  ngOnInit() {
    this.terminator.onDestroy.subscribe(() => this.ngOnDestroy());
  }
  ngOnChanges() {
    const p = this.formProperty;
    this.ref = this.widgetFactory.createWidget(this.container, p.ui.widget || p.schema.type);
    this.onWidgetInstanciated(this.ref.instance);
  }
  ngOnDestroy() {
    const {
      destroy$
    } = this;
    destroy$.next();
    destroy$.complete();
    this.ref.destroy();
  }
};
_SFItemComponent.ɵfac = function SFItemComponent_Factory(t) {
  return new (t || _SFItemComponent)();
};
_SFItemComponent.ɵcmp = ɵɵdefineComponent({
  type: _SFItemComponent,
  selectors: [["sf-item"]],
  viewQuery: function SFItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function SFItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("sf__item", true);
    }
  },
  inputs: {
    formProperty: "formProperty",
    footer: "footer"
  },
  exportAs: ["sfItem"],
  features: [ɵɵProvidersFeature([NzFormStatusService]), ɵɵNgOnChangesFeature],
  decls: 3,
  vars: 1,
  consts: [["target", ""], [4, "ngTemplateOutlet"]],
  template: function SFItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, SFItemComponent_ng_template_0_Template, 0, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, SFItemComponent_ng_container_2_Template, 1, 0, "ng-container", 1);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.footer);
    }
  },
  dependencies: [NgTemplateOutlet],
  encapsulation: 2
});
var SFItemComponent = _SFItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFItemComponent, [{
    type: Component,
    args: [{
      selector: "sf-item",
      exportAs: "sfItem",
      host: {
        "[class.sf__item]": "true"
      },
      template: `
    <ng-template #target />
    <ng-container *ngTemplateOutlet="footer" />
  `,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      providers: [NzFormStatusService]
    }]
  }], null, {
    formProperty: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    container: [{
      type: ViewChild,
      args: ["target", {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var _SFFixedDirective = class _SFFixedDirective {
  constructor() {
    this.el = inject(ElementRef).nativeElement;
    this.render = inject(Renderer2);
    this._inited = false;
  }
  init() {
    if (!this._inited || this.num == null || this.num <= 0)
      return;
    const el = this.el;
    const widgetEl = el.querySelector(".ant-row") || el;
    this.render.addClass(widgetEl, "sf__fixed");
    const labelEl = widgetEl.querySelector(".ant-form-item-label");
    const controlEl = widgetEl.querySelector(".ant-form-item-control-wrapper,.ant-form-item-control");
    const unit = `${this.num}px`;
    if (labelEl) {
      this.render.setStyle(labelEl, "flex", `0 0 ${unit}`);
      this.render.setStyle(controlEl, "max-width", `calc(100% - ${unit})`);
    } else {
      this.render.setStyle(controlEl, "margin-left", unit);
    }
  }
  ngAfterViewInit() {
    this._inited = true;
    this.init();
  }
  ngOnChanges() {
    if (this._inited)
      this.init();
  }
};
_SFFixedDirective.ɵfac = function SFFixedDirective_Factory(t) {
  return new (t || _SFFixedDirective)();
};
_SFFixedDirective.ɵdir = ɵɵdefineDirective({
  type: _SFFixedDirective,
  selectors: [["", "fixed-label", ""]],
  inputs: {
    num: [InputFlags.HasDecoratorInputTransform, "fixed-label", "num", (v) => numberAttribute(v, 0)]
  },
  features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
});
var SFFixedDirective = _SFFixedDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFFixedDirective, [{
    type: Directive,
    args: [{
      selector: "[fixed-label]"
    }]
  }], null, {
    num: [{
      type: Input,
      args: [{
        alias: "fixed-label",
        transform: (v) => numberAttribute(v, 0)
      }]
    }]
  });
})();
function useFactory(injector, schemaValidatorFactory, cogSrv) {
  return new FormPropertyFactory(injector, schemaValidatorFactory, cogSrv);
}
var _SFComponent = class _SFComponent {
  get btnGrid() {
    return this._btn.render.grid;
  }
  /**
   * Form default mode, will force override `layout`, `firstVisual`, `liveValidate` parameters
   *
   * 表单预设模式，会强制覆盖 `layout`，`firstVisual`，`liveValidate` 参数
   */
  set mode(value) {
    switch (value) {
      case "search":
        this.layout = "inline";
        this.firstVisual = false;
        this.liveValidate = false;
        if (this._btn) {
          this._btn.submit = this._btn.search;
        }
        break;
      case "edit":
        this.layout = "horizontal";
        this.firstVisual = false;
        this.liveValidate = true;
        if (this._btn) {
          this._btn.submit = this._btn.edit;
        }
        break;
    }
    this._mode = value;
  }
  get mode() {
    return this._mode;
  }
  // #endregion
  /**
   * Whether the form is valid
   *
   * 表单是否有效
   */
  get valid() {
    return this._valid;
  }
  /**
   * The value of the form
   *
   * 表单值
   */
  get value() {
    return this._item;
  }
  /**
   * Get form element property based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)获取表单元素属性
   */
  getProperty(path) {
    return this.rootProperty?.searchProperty(path);
  }
  /**
   * Get element value based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)获取表单元素值
   */
  getValue(path) {
    return this.getProperty(path)?.value;
  }
  /**
   * Set form element new value based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)设置某个表单元素属性值
   */
  setValue(path, value) {
    const item = this.getProperty(path);
    if (!item) {
      throw new Error(`Invalid path: ${path}`);
    }
    item.resetValue(value, false);
    return this;
  }
  /**
   * Set form element new `disabled` based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)设置某个表单元素 `disabled` 状态
   */
  setDisabled(path, status) {
    const property = this.getProperty(path);
    if (!property) {
      throw new Error(`Invalid path: ${path}`);
    }
    property.schema.readOnly = status;
    property.widget.detectChanges();
    return this;
  }
  /**
   * Set form element new `required` based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)设置某个表单元素 `required` 状态
   */
  setRequired(path, status) {
    const property = this.getProperty(path);
    if (!property) {
      throw new Error(`Invalid path: ${path}`);
    }
    const key = path.split(SF_SEQ).pop();
    const parentRequired = property.parent?.schema.required || [];
    const idx = parentRequired.findIndex((w) => w === key);
    if (status) {
      if (idx === -1)
        parentRequired.push(key);
    } else {
      if (idx !== -1)
        parentRequired.splice(idx, 1);
    }
    property.parent.schema.required = parentRequired;
    property.ui._required = status;
    property.widget.detectChanges();
    this.validator({
      onlyRoot: false
    });
    return this;
  }
  /**
   * Update the feedback status of the widget
   *
   * 更新小部件的反馈状态
   *
   * ```ts
   * // Validate status of the widget
   * this.sf.updateFeedback('/name', 'validating');
   * // Clean validate status of the widget
   * this.sf.updateFeedback('/name');
   * ```
   */
  updateFeedback(path, status = "") {
    this.getProperty(path)?.updateFeedback(status);
    return this;
  }
  onSubmit(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!this.liveValidate)
      this.validator();
    if (!this.valid)
      return;
    this.formSubmit.emit(this.value);
  }
  constructor(cogSrv) {
    this.formPropertyFactory = inject(FormPropertyFactory);
    this.terminator = inject(TerminatorService);
    this.dom = inject(DomSanitizer);
    this.cdr = inject(ChangeDetectorRef);
    this.localeSrv = inject(DelonLocaleService);
    this.aclSrv = inject(ACLService, {
      optional: true
    });
    this.i18nSrv = inject(ALAIN_I18N_TOKEN, {
      optional: true
    });
    this.platform = inject(Platform);
    this._renders = /* @__PURE__ */ new Map();
    this._valid = true;
    this._inited = false;
    this.locale = {};
    this.rootProperty = null;
    this.layout = "horizontal";
    this.button = {};
    this.liveValidate = true;
    this.firstVisual = true;
    this.onlyVisual = false;
    this.compact = false;
    this.loading = false;
    this.disabled = false;
    this.noColon = false;
    this.cleanValue = false;
    this.delay = false;
    this.formValueChange = new EventEmitter();
    this.formChange = new EventEmitter();
    this.formSubmit = new EventEmitter();
    this.formReset = new EventEmitter();
    this.formError = new EventEmitter();
    this.options = mergeConfig(cogSrv);
    this.liveValidate = this.options.liveValidate;
    this.firstVisual = this.options.firstVisual;
    this.autocomplete = this.options.autocomplete;
    this.delay = this.options.delay;
    this.localeSrv.change.pipe(takeUntilDestroyed()).subscribe(() => {
      this.locale = this.localeSrv.getData("sf");
      if (this._inited) {
        this.validator({
          emitError: false,
          onlyRoot: false
        });
        this.coverButtonProperty();
        this.cdr.markForCheck();
      }
    });
    const refSchemas = [this.aclSrv ? this.aclSrv.change : null, this.i18nSrv ? this.i18nSrv.change : null].filter((o) => o != null);
    if (refSchemas.length > 0) {
      merge(...refSchemas).pipe(filter(() => this._inited), takeUntilDestroyed()).subscribe(() => this.refreshSchema());
    }
  }
  fanyi(key) {
    return (this.i18nSrv ? this.i18nSrv.fanyi(key) : "") || key;
  }
  inheritUI(ui) {
    ["optionalHelp"].filter((key) => !!this._defUi[key]).forEach((key) => ui[key] = __spreadValues(__spreadValues({}, this._defUi[key]), ui[key]));
  }
  coverProperty() {
    const isHorizontal = this.layout === "horizontal";
    const _schema = deepCopy(this.schema);
    const {
      definitions
    } = _schema;
    const inFn = (schema, _parentSchema, uiSchema, parentUiSchema, uiRes) => {
      if (!Array.isArray(schema.required))
        schema.required = [];
      Object.keys(schema.properties).forEach((key) => {
        const uiKeyPrefix = "$";
        const uiKey = uiKeyPrefix + key;
        const property = retrieveSchema(schema.properties[key], definitions);
        const curUi = __spreadValues(__spreadValues({}, property.ui), uiSchema[uiKey]);
        const ui = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues({}, this._defUi), parentUiSchema), {
          // 忽略部分会引起呈现的属性
          visibleIf: void 0,
          hidden: void 0,
          optional: void 0,
          optionalHelp: void 0,
          widget: property.type
        }), property.format && this.options.formatMap[property.format]), typeof property.ui === "string" ? {
          widget: property.ui
        } : null), !property.format && !property.ui && Array.isArray(property.enum) && property.enum.length > 0 ? {
          widget: "select"
        } : null), curUi);
        Object.keys(ui).filter((key2) => key2.startsWith(uiKeyPrefix)).forEach((key2) => delete ui[key2]);
        if (isHorizontal) {
          if (parentUiSchema.spanLabelFixed) {
            if (!curUi.spanLabelFixed) {
              ui.spanLabelFixed = parentUiSchema.spanLabelFixed;
            }
          } else {
            if (!ui.spanLabel)
              ui.spanLabel = typeof parentUiSchema.spanLabel === "undefined" ? 5 : parentUiSchema.spanLabel;
            if (!ui.spanControl)
              ui.spanControl = typeof parentUiSchema.spanControl === "undefined" ? 19 : parentUiSchema.spanControl;
            if (!ui.offsetControl)
              ui.offsetControl = typeof parentUiSchema.offsetControl === "undefined" ? null : parentUiSchema.offsetControl;
          }
        } else {
          ui.spanLabel = null;
          ui.spanControl = null;
          ui.offsetControl = null;
        }
        if (this.layout === "inline") {
          delete ui.grid;
        }
        if (this.layout !== "horizontal") {
          ui.spanLabelFixed = null;
        }
        if (ui.spanLabelFixed != null && ui.spanLabelFixed > 0) {
          ui.spanLabel = null;
          ui.spanControl = null;
        }
        if (ui.widget === "date" && ui.end != null) {
          const dateEndProperty = schema.properties[ui.end];
          if (dateEndProperty) {
            dateEndProperty.ui = __spreadProps(__spreadValues({}, dateEndProperty.ui), {
              widget: ui.widget,
              hidden: true
            });
          } else {
            ui.end = null;
          }
        }
        this.inheritUI(ui);
        if (ui.optionalHelp) {
          if (typeof ui.optionalHelp === "string") {
            ui.optionalHelp = {
              text: ui.optionalHelp
            };
          }
          const oh = ui.optionalHelp = __spreadValues({
            text: "",
            icon: "question-circle",
            placement: "top",
            trigger: "hover",
            mouseEnterDelay: 0.15,
            mouseLeaveDelay: 0.1
          }, ui.optionalHelp);
          if (oh.i18n) {
            oh.text = this.fanyi(oh.i18n);
          }
          if (!oh.text) {
            ui.optionalHelp = void 0;
          }
        }
        if (ui.i18n) {
          property.title = this.fanyi(ui.i18n);
        }
        if (ui.descriptionI18n) {
          property.description = this.fanyi(ui.descriptionI18n);
        }
        if (property.description) {
          ui._description = this.dom.bypassSecurityTrustHtml(property.description);
        }
        ui.hidden = typeof ui.hidden === "boolean" ? ui.hidden : false;
        if (ui.hidden === false && ui.acl && this.aclSrv && !this.aclSrv.can(ui.acl)) {
          ui.hidden = true;
        }
        uiRes[uiKey] = ui;
        delete property.ui;
        if (ui.hidden === true) {
          const idx = schema.required.indexOf(key);
          if (idx !== -1) {
            schema.required.splice(idx, 1);
          }
        }
        if (property.items) {
          ui.$items = __spreadValues(__spreadValues(__spreadValues({}, property.items.ui), uiSchema[uiKey]), ui.$items);
          inFn(property.items, property.items, uiSchema[uiKey]?.$items ?? {}, ui.$items, ui.$items);
        }
        if (property.properties && Object.keys(property.properties).length) {
          inFn(property, schema, uiSchema[uiKey] || {}, ui, ui);
        }
      });
    };
    if (this.ui == null)
      this.ui = {};
    this._defUi = __spreadValues(__spreadValues(__spreadValues({
      onlyVisual: this.options.onlyVisual,
      size: this.options.size,
      liveValidate: this.liveValidate
    }, this.options.ui), _schema.ui), this.ui["*"]);
    if (this.onlyVisual === true) {
      this._defUi.onlyVisual = true;
    }
    if (this.layout === "inline") {
      delete this._defUi.grid;
    }
    this._ui = __spreadValues({}, this._defUi);
    inFn(_schema, _schema, this.ui, this.ui, this._ui);
    resolveIfSchema(_schema, this._ui);
    this._schema = _schema;
    delete _schema.ui;
    di(this._ui, "cover schema & ui", this._ui, _schema);
  }
  coverButtonProperty() {
    this._btn = __spreadValues(__spreadValues(__spreadValues({
      render: {
        size: "default"
      }
    }, this.locale), this.options.button), this.button);
    const firstKey = Object.keys(this._ui).find((w) => w.startsWith("$"));
    const btnRender = this._btn.render;
    if (this.layout === "horizontal") {
      const btnUi = firstKey ? this._ui[firstKey] : this._defUi;
      if (!btnRender.grid) {
        btnRender.grid = {
          offset: btnUi.spanLabel,
          span: btnUi.spanControl
        };
      }
      if (btnRender.spanLabelFixed == null) {
        btnRender.spanLabelFixed = btnUi.spanLabelFixed;
      }
      if (!btnRender.class && typeof btnUi.spanLabelFixed === "number" && btnUi.spanLabelFixed > 0) {
        btnRender.class = "text-center";
      }
    } else {
      btnRender.grid = {};
    }
    if (this._mode) {
      this.mode = this._mode;
    }
    di(this._ui, "button property", this._btn);
  }
  ngOnInit() {
    if (!this.platform.isBrowser) {
      return;
    }
    this.validator();
    this._inited = true;
  }
  ngOnChanges(changes) {
    if (!this.platform.isBrowser) {
      return;
    }
    const ingoreRender = ["disabled", "loading"];
    if (Object.keys(changes).every((key) => ingoreRender.includes(key))) {
      this.cdr.detectChanges();
      return;
    }
    if (!this.delay) {
      this.refreshSchema();
    }
  }
  /** @internal */
  _addTpl(path, templateRef) {
    if (!this._inited) {
      return;
    }
    if (this._renders.has(path)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        console.warn(`Duplicate definition "${path}" custom widget`);
      }
      return;
    }
    this._renders.set(path, templateRef);
    this.attachCustomRender();
  }
  attachCustomRender() {
    this._renders.forEach((tpl, path) => {
      const property = this.rootProperty?.searchProperty(path);
      if (property == null) {
        return;
      }
      property.ui._render = tpl;
    });
  }
  /**
   * Validator the form is valid
   *
   * 校验表单是否有效
   * - `emitError` 当表单无效时是否触发 `formError` 事件，默认：`true`
   * - `onlyRoot` 只对根进行检验，不进行向下逐个递归，根已经包含整个 Json Schema，默认：`true`
   */
  validator(options = {
    emitError: true,
    onlyRoot: true
  }) {
    if (this.rootProperty == null || !this.platform.isBrowser) {
      return false;
    }
    const fn = (property) => {
      property._runValidation();
      if (!(property instanceof PropertyGroup) || !property.properties)
        return;
      if (Array.isArray(property.properties)) {
        property.properties.forEach((p) => fn(p));
      } else {
        Object.keys(property.properties).forEach((key) => fn(property.properties[key]));
      }
    };
    if (options.onlyRoot) {
      this.rootProperty._runValidation();
    } else {
      fn(this.rootProperty);
    }
    const errors = this.rootProperty.errors;
    this._valid = !(errors && errors.length);
    if (options.emitError && !this._valid)
      this.formError.emit(errors);
    this.cdr.detectChanges();
    return this._valid;
  }
  /**
   * Refresh the form Schema, when specifying `newSchema` means to replace the current Schema
   *
   * 刷新 Schema，当指定 `newSchema` 表示替换当前的 Schema
   *
   * 可以针对某个表单元素进行刷新，例如：
   * ```
   * // 获取某个元素
   * const statusProperty = this.sf.getProperty('/status')!;
   * // 重置 `schema` 或 `ui` 参数
   * statusProperty.schema.enum = ['1', '2', '3'];
   * // 调用 `reset` 重置初始值
   * statusProperty.widget.reset('2');
   * ```
   */
  refreshSchema(newSchema, newUI) {
    if (!this.platform.isBrowser) {
      return this;
    }
    if (newSchema)
      this.schema = newSchema;
    if (newUI)
      this.ui = newUI;
    if (!this.schema || typeof this.schema.properties === "undefined")
      throw new Error(`Invalid Schema`);
    if (this.schema.ui && typeof this.schema.ui === "string")
      throw new Error(`Don't support string with root ui property`);
    this.schema.type = "object";
    this._formData = __spreadValues({}, this.formData);
    if (this._inited)
      this.terminator.destroy();
    this.cleanRootSub();
    this.coverProperty();
    this.coverButtonProperty();
    this.rootProperty = this.formPropertyFactory.createProperty(this._schema, this._ui, this.formData);
    this.attachCustomRender();
    this.cdr.detectChanges();
    this.reset();
    let isFirst = true;
    this.rootProperty.valueChanges.subscribe((res) => {
      this._item = __spreadValues(__spreadValues({}, this.cleanValue ? null : this.formData), res.value);
      if (isFirst) {
        isFirst = false;
        return;
      }
      this.formChange.emit(this._item);
      this.formValueChange.emit({
        value: this._item,
        path: res.path,
        pathValue: res.pathValue
      });
    });
    this.rootProperty.errorsChanges.subscribe((errors) => {
      this._valid = !(errors && errors.length);
      this.formError.emit(errors);
      this.cdr.detectChanges();
    });
    return this;
  }
  /**
   * Reset form
   *
   * 重置表单
   *
   * @param [emit] 是否触发 `formReset` 事件，默认：`false`
   */
  reset(emit = false) {
    if (this.rootProperty == null || !this.platform.isBrowser) {
      return this;
    }
    this.rootProperty.resetValue(this.formData, false);
    Promise.resolve().then(() => this.cdr.detectChanges());
    if (emit) {
      this.formReset.emit(this.value);
    }
    return this;
  }
  cleanRootSub() {
    if (!this.rootProperty)
      return;
    this.rootProperty.errorsChanges.unsubscribe();
    this.rootProperty.valueChanges.unsubscribe();
  }
  ngOnDestroy() {
    this.cleanRootSub();
    this.terminator.destroy();
  }
};
_SFComponent.ɵfac = function SFComponent_Factory(t) {
  return new (t || _SFComponent)(ɵɵdirectiveInject(AlainConfigService));
};
_SFComponent.ɵcmp = ɵɵdefineComponent({
  type: _SFComponent,
  selectors: [["sf"], ["", "sf", ""]],
  hostVars: 16,
  hostBindings: function SFComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("sf", true)("sf__inline", ctx.layout === "inline")("sf__horizontal", ctx.layout === "horizontal")("sf__search", ctx.mode === "search")("sf__edit", ctx.mode === "edit")("sf__no-error", ctx.onlyVisual)("sf__no-colon", ctx.noColon)("sf__compact", ctx.compact);
    }
  },
  inputs: {
    layout: "layout",
    schema: "schema",
    ui: "ui",
    formData: "formData",
    button: "button",
    liveValidate: [InputFlags.HasDecoratorInputTransform, "liveValidate", "liveValidate", booleanAttribute],
    autocomplete: "autocomplete",
    firstVisual: [InputFlags.HasDecoratorInputTransform, "firstVisual", "firstVisual", booleanAttribute],
    onlyVisual: [InputFlags.HasDecoratorInputTransform, "onlyVisual", "onlyVisual", booleanAttribute],
    compact: [InputFlags.HasDecoratorInputTransform, "compact", "compact", booleanAttribute],
    mode: "mode",
    loading: [InputFlags.HasDecoratorInputTransform, "loading", "loading", booleanAttribute],
    disabled: [InputFlags.HasDecoratorInputTransform, "disabled", "disabled", booleanAttribute],
    noColon: [InputFlags.HasDecoratorInputTransform, "noColon", "noColon", booleanAttribute],
    cleanValue: [InputFlags.HasDecoratorInputTransform, "cleanValue", "cleanValue", booleanAttribute],
    delay: [InputFlags.HasDecoratorInputTransform, "delay", "delay", booleanAttribute]
  },
  outputs: {
    formValueChange: "formValueChange",
    formChange: "formChange",
    formSubmit: "formSubmit",
    formReset: "formReset",
    formError: "formError"
  },
  exportAs: ["sf"],
  features: [ɵɵProvidersFeature([WidgetFactory, {
    provide: FormPropertyFactory,
    useFactory,
    deps: [Injector, SchemaValidatorFactory, AlainConfigService]
  }, TerminatorService]), ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature],
  ngContentSelectors: _c1,
  decls: 6,
  vars: 3,
  consts: [["con", ""], ["btnTpl", ""], ["nz-form", "", 3, "nzLayout", "submit"], [3, "formProperty", "footer"], ["class", "sf-btns", 3, "ngClass", "fixed-label"], [1, "sf-btns", 3, "ngClass", "fixed-label"], ["nz-col", "", 1, "ant-form-item-control", 3, "nzSpan", "nzOffset", "nzXs", "nzSm", "nzMd", "nzLg", "nzXl", "nzXXl"], [1, "ant-form-item-control-input"], [1, "ant-form-item-control-input-content"], ["type", "submit", "nz-button", "", "data-type", "submit", 3, "nzType", "nzSize", "nzLoading", "disabled"], ["nz-icon", "", 3, "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], ["type", "button", "nz-button", "", "data-type", "reset", 3, "nzType", "nzSize", "disabled"], ["type", "button", "nz-button", "", "data-type", "reset", 3, "nzType", "nzSize", "disabled", "click"], [3, "ngTemplateOutlet"]],
  template: function SFComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, SFComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, SFComponent_ng_template_2_Template, 2, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementStart(4, "form", 2);
      ɵɵlistener("submit", function SFComponent_Template_form_submit_4_listener($event) {
        return ctx.onSubmit($event);
      });
      ɵɵtemplate(5, SFComponent_Conditional_5_Template, 1, 2, "sf-item", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(4);
      ɵɵproperty("nzLayout", ctx.layout);
      ɵɵattribute("autocomplete", ctx.autocomplete);
      ɵɵadvance();
      ɵɵconditional(5, ctx.rootProperty ? 5 : -1);
    }
  },
  dependencies: [NgClass, NgTemplateOutlet, ɵNgNoValidate, NgControlStatusGroup, NgForm, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, NzColDirective, NzRowDirective, NzFormDirective, NzFormItemComponent, NzIconDirective, SFItemComponent, SFFixedDirective],
  encapsulation: 2,
  changeDetection: 0
});
var SFComponent = _SFComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFComponent, [{
    type: Component,
    args: [{
      selector: "sf, [sf]",
      exportAs: "sf",
      providers: [WidgetFactory, {
        provide: FormPropertyFactory,
        useFactory,
        deps: [Injector, SchemaValidatorFactory, AlainConfigService]
      }, TerminatorService],
      host: {
        "[class.sf]": "true",
        "[class.sf__inline]": `layout === 'inline'`,
        "[class.sf__horizontal]": `layout === 'horizontal'`,
        "[class.sf__search]": `mode === 'search'`,
        "[class.sf__edit]": `mode === 'edit'`,
        "[class.sf__no-error]": `onlyVisual`,
        "[class.sf__no-colon]": `noColon`,
        "[class.sf__compact]": `compact`
      },
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<ng-template #con>
  <ng-content />
</ng-template>
<ng-template #btnTpl>
  @if (button !== 'none') {
    @if (_btn && _btn.render) {
      <nz-form-item [ngClass]="_btn.render!.class!" class="sf-btns" [fixed-label]="_btn.render!.spanLabelFixed!">
        <div
          nz-col
          class="ant-form-item-control"
          [nzSpan]="btnGrid.span"
          [nzOffset]="btnGrid.offset"
          [nzXs]="btnGrid.xs"
          [nzSm]="btnGrid.sm"
          [nzMd]="btnGrid.md"
          [nzLg]="btnGrid.lg"
          [nzXl]="btnGrid.xl"
          [nzXXl]="btnGrid.xxl"
        >
          <div class="ant-form-item-control-input">
            <div class="ant-form-item-control-input-content">
              @if (button) {
                <button
                  type="submit"
                  nz-button
                  data-type="submit"
                  [nzType]="_btn.submit_type!"
                  [nzSize]="_btn.render!.size!"
                  [nzLoading]="loading"
                  [disabled]="liveValidate && !valid"
                >
                  @if (_btn.submit_icon) {
                    <i
                      nz-icon
                      [nzType]="_btn.submit_icon.type!"
                      [nzTheme]="_btn.submit_icon.theme!"
                      [nzTwotoneColor]="_btn.submit_icon.twoToneColor!"
                      [nzIconfont]="_btn.submit_icon.iconfont!"
                    ></i>
                  }
                  {{ _btn.submit }}
                </button>
                @if (_btn.reset) {
                  <button
                    type="button"
                    nz-button
                    data-type="reset"
                    [nzType]="_btn.reset_type!"
                    [nzSize]="_btn.render!.size!"
                    [disabled]="loading"
                    (click)="reset(true)"
                  >
                    @if (_btn.reset_icon) {
                      <i
                        nz-icon
                        [nzType]="_btn.reset_icon.type!"
                        [nzTheme]="_btn.reset_icon.theme!"
                        [nzTwotoneColor]="_btn.reset_icon.twoToneColor!"
                        [nzIconfont]="_btn.reset_icon.iconfont!"
                      ></i>
                    }
                    {{ _btn.reset }}
                  </button>
                }
              } @else {
                <ng-template [ngTemplateOutlet]="con" />
              }
            </div>
          </div>
        </div>
      </nz-form-item>
    }
  } @else {
    <ng-template [ngTemplateOutlet]="con" />
  }
</ng-template>
<form nz-form [nzLayout]="layout" (submit)="onSubmit($event)" [attr.autocomplete]="autocomplete">
  @if (rootProperty) {
    <sf-item [formProperty]="rootProperty" [footer]="btnTpl" />
  }
</form>
`
    }]
  }], () => [{
    type: AlainConfigService
  }], {
    layout: [{
      type: Input
    }],
    schema: [{
      type: Input
    }],
    ui: [{
      type: Input
    }],
    formData: [{
      type: Input
    }],
    button: [{
      type: Input
    }],
    liveValidate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    autocomplete: [{
      type: Input
    }],
    firstVisual: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    onlyVisual: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    compact: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    mode: [{
      type: Input
    }],
    loading: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    noColon: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    cleanValue: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    delay: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    formValueChange: [{
      type: Output
    }],
    formChange: [{
      type: Output
    }],
    formSubmit: [{
      type: Output
    }],
    formReset: [{
      type: Output
    }],
    formError: [{
      type: Output
    }]
  });
})();
var _SFItemWrapComponent = class _SFItemWrapComponent {
  constructor() {
    this.statusSrv = inject(NzFormStatusService);
    this._showTitle = false;
    this.title = null;
  }
  set showTitle(val) {
    this._showTitle = !!val;
  }
  get t() {
    return this.title === null ? this.schema.title : this.title;
  }
  get oh() {
    return this.ui.optionalHelp;
  }
  ngOnChanges() {
    const hasError = !!this.error;
    this.statusSrv.formStatusChanges.next({
      status: hasError ? "error" : "",
      hasFeedback: !!this.ui.feedback
    });
  }
};
_SFItemWrapComponent.ɵfac = function SFItemWrapComponent_Factory(t) {
  return new (t || _SFItemWrapComponent)();
};
_SFItemWrapComponent.ɵcmp = ɵɵdefineComponent({
  type: _SFItemWrapComponent,
  selectors: [["sf-item-wrap"]],
  inputs: {
    id: "id",
    schema: "schema",
    ui: "ui",
    showError: "showError",
    error: "error",
    showTitle: "showTitle",
    title: "title"
  },
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c1,
  decls: 8,
  vars: 21,
  consts: [["nz-col", "", "class", "ant-form-item-label", 3, "nzSpan"], ["nz-col", "", 1, "ant-form-item-control", 3, "nzSpan", "nzOffset"], [1, "ant-form-item-control-input"], [1, "ant-form-item-control-input-content"], ["class", "ant-form-item-explain ant-form-item-explain-connected"], ["class", "ant-form-item-extra", 3, "innerHTML"], ["nz-col", "", 1, "ant-form-item-label", 3, "nzSpan"], [3, "ant-form-item-required"], [1, "sf__label-text"], ["class", "sf__optional"], [1, "sf__optional"], ["nz-tooltip", "", "nz-icon", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipColor", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [1, "ant-form-item-explain", "ant-form-item-explain-connected"], ["role", "alert", 1, "ant-form-item-explain-error"], [1, "ant-form-item-extra", 3, "innerHTML"]],
  template: function SFItemWrapComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "nz-form-item");
      ɵɵtemplate(1, SFItemWrapComponent_Conditional_1_Template, 2, 2, "div", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      ɵɵprojection(5);
      ɵɵelementEnd()();
      ɵɵtemplate(6, SFItemWrapComponent_Conditional_6_Template, 3, 2, "div", 4)(7, SFItemWrapComponent_Conditional_7_Template, 1, 1, "div", 5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵstyleProp("width", ctx.ui.width, "px");
      ɵɵclassProp("ant-form-item-has-error", ctx.showError)("ant-form-item-with-help", ctx.showError)("ant-form-item-has-success", ctx.ui.feedback === "success")("ant-form-item-has-warning", ctx.ui.feedback === "warning")("ant-form-item-has-error", ctx.ui.feedback === "error")("ant-form-item-is-validating", ctx.ui.feedback === "validating")("ant-form-item-has-feedback", ctx.ui.feedback);
      ɵɵadvance();
      ɵɵconditional(1, ctx._showTitle ? 1 : -1);
      ɵɵadvance();
      ɵɵproperty("nzSpan", ctx.ui.spanControl)("nzOffset", ctx.ui.offsetControl);
      ɵɵadvance(4);
      ɵɵconditional(6, !ctx.ui.onlyVisual && ctx.showError ? 6 : -1);
      ɵɵadvance();
      ɵɵconditional(7, ctx.schema.description ? 7 : -1);
    }
  },
  dependencies: [NzTransitionPatchDirective, NzColDirective, NzRowDirective, NzFormItemComponent, NzIconDirective, NzTooltipDirective],
  encapsulation: 2,
  data: {
    animation: [helpMotion]
  }
});
var SFItemWrapComponent = _SFItemWrapComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFItemWrapComponent, [{
    type: Component,
    args: [{
      selector: "sf-item-wrap",
      animations: [helpMotion],
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None,
      template: `<nz-form-item
  [style.width.px]="ui.width"
  [class.ant-form-item-has-error]="showError"
  [class.ant-form-item-with-help]="showError"
  [class.ant-form-item-has-success]="ui.feedback === 'success'"
  [class.ant-form-item-has-warning]="ui.feedback === 'warning'"
  [class.ant-form-item-has-error]="ui.feedback === 'error'"
  [class.ant-form-item-is-validating]="ui.feedback === 'validating'"
  [class.ant-form-item-has-feedback]="ui.feedback"
>
  @if (_showTitle) {
    <div nz-col [nzSpan]="ui.spanLabel!" class="ant-form-item-label">
      @if (t) {
        <label [attr.for]="id" [class.ant-form-item-required]="ui._required">
          <span class="sf__label-text">{{ t }}</span>
          @if (ui.optional || oh) {
            <span class="sf__optional">
              {{ ui.optional }}
              @if (oh) {
                <i
                  nz-tooltip
                  [nzTooltipTitle]="oh.text"
                  [nzTooltipPlacement]="oh.placement"
                  [nzTooltipTrigger]="oh.trigger"
                  [nzTooltipColor]="oh.bgColor"
                  [nzTooltipOverlayClassName]="oh.overlayClassName"
                  [nzTooltipOverlayStyle]="oh.overlayStyle"
                  [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                  [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                  nz-icon
                  [nzType]="oh.icon!"
                ></i>
              }
            </span>
          }
        </label>
      }
    </div>
  }
  <div nz-col class="ant-form-item-control" [nzSpan]="ui.spanControl!" [nzOffset]="ui.offsetControl!">
    <div class="ant-form-item-control-input">
      <div class="ant-form-item-control-input-content">
        <ng-content />
      </div>
    </div>
    @if (!ui.onlyVisual && showError) {
      <div @helpMotion class="ant-form-item-explain ant-form-item-explain-connected">
        <div role="alert" class="ant-form-item-explain-error">
          {{ error }}
        </div>
      </div>
    }
    @if (schema.description) {
      <div class="ant-form-item-extra" [innerHTML]="ui._description"></div>
    }
  </div>
</nz-form-item>
`
    }]
  }], null, {
    id: [{
      type: Input
    }],
    schema: [{
      type: Input
    }],
    ui: [{
      type: Input
    }],
    showError: [{
      type: Input
    }],
    error: [{
      type: Input
    }],
    showTitle: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var _SFTemplateDirective = class _SFTemplateDirective {
  constructor() {
    this.table = inject(SFComponent);
    this.templateRef = inject(TemplateRef);
  }
  ngOnInit() {
    this.table._addTpl(this.path.startsWith(SF_SEQ) ? this.path : SF_SEQ + this.path, this.templateRef);
  }
};
_SFTemplateDirective.ɵfac = function SFTemplateDirective_Factory(t) {
  return new (t || _SFTemplateDirective)();
};
_SFTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: _SFTemplateDirective,
  selectors: [["", "sf-template", ""]],
  inputs: {
    path: [InputFlags.None, "sf-template", "path"]
  }
});
var SFTemplateDirective = _SFTemplateDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[sf-template]"
    }]
  }], null, {
    path: [{
      type: Input,
      args: ["sf-template"]
    }]
  });
})();
var _Widget = class _Widget {
  constructor() {
    this.cd = inject(ChangeDetectorRef);
    this.injector = inject(Injector);
    this.sfItemComp = inject(SFItemComponent);
    this.sfComp = inject(SFComponent);
    this.showError = false;
    this.id = "";
  }
  get cls() {
    return this.ui.class || "";
  }
  get disabled() {
    if (this.schema.readOnly === true || this.sfComp.disabled) {
      return true;
    }
    return false;
  }
  get l() {
    return this.formProperty.root.widget.sfComp.locale;
  }
  get oh() {
    return this.ui.optionalHelp;
  }
  get dom() {
    return this.injector.get(DomSanitizer);
  }
  get cleanValue() {
    return this.sfComp?.cleanValue;
  }
  ngAfterViewInit() {
    this.formProperty.errorsChanges.pipe(takeUntil(this.sfItemComp.destroy$)).subscribe((errors) => {
      if (errors == null)
        return;
      di(this.ui, "errorsChanges", this.formProperty.path, errors);
      const firstVisual = this.sfComp?.firstVisual;
      if (firstVisual || !firstVisual && this.sfComp?._inited) {
        this.showError = errors.length > 0;
        this.error = this.showError ? errors[0].message : "";
        this.cd.detectChanges();
      }
    });
    this.afterViewInit();
  }
  setValue(value) {
    this.formProperty.setValue(value, false);
    di(this.ui, "valueChanges", this.formProperty.path, this.formProperty);
  }
  get value() {
    return this.formProperty.value;
  }
  detectChanges(onlySelf = false) {
    if (onlySelf) {
      this.cd.markForCheck();
    } else {
      this.formProperty.root.widget?.cd.markForCheck();
    }
  }
};
_Widget.ɵfac = function Widget_Factory(t) {
  return new (t || _Widget)();
};
_Widget.ɵdir = ɵɵdefineDirective({
  type: _Widget,
  hostVars: 2,
  hostBindings: function Widget_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.cls);
    }
  }
});
var Widget = _Widget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Widget, [{
    type: Directive
  }], null, {
    cls: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _ControlWidget = class _ControlWidget extends Widget {
  reset(_value) {
  }
  afterViewInit() {
  }
};
_ControlWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵControlWidget_BaseFactory;
  return function ControlWidget_Factory(t) {
    return (ɵControlWidget_BaseFactory || (ɵControlWidget_BaseFactory = ɵɵgetInheritedFactory(_ControlWidget)))(t || _ControlWidget);
  };
})();
_ControlWidget.ɵdir = ɵɵdefineDirective({
  type: _ControlWidget,
  features: [ɵɵInheritDefinitionFeature]
});
var ControlWidget = _ControlWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlWidget, [{
    type: Directive
  }], null, null);
})();
var _ControlUIWidget = class _ControlUIWidget extends Widget {
  reset(_value) {
  }
  afterViewInit() {
  }
};
_ControlUIWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵControlUIWidget_BaseFactory;
  return function ControlUIWidget_Factory(t) {
    return (ɵControlUIWidget_BaseFactory || (ɵControlUIWidget_BaseFactory = ɵɵgetInheritedFactory(_ControlUIWidget)))(t || _ControlUIWidget);
  };
})();
_ControlUIWidget.ɵdir = ɵɵdefineDirective({
  type: _ControlUIWidget,
  features: [ɵɵInheritDefinitionFeature]
});
var ControlUIWidget = _ControlUIWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlUIWidget, [{
    type: Directive
  }], null, null);
})();
var _ArrayLayoutWidget = class _ArrayLayoutWidget extends Widget {
  reset(_value) {
  }
  afterViewInit() {
  }
  ngAfterViewInit() {
    this.formProperty.errorsChanges.pipe(takeUntil(this.sfItemComp.destroy$)).subscribe(() => this.cd.detectChanges());
  }
};
_ArrayLayoutWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵArrayLayoutWidget_BaseFactory;
  return function ArrayLayoutWidget_Factory(t) {
    return (ɵArrayLayoutWidget_BaseFactory || (ɵArrayLayoutWidget_BaseFactory = ɵɵgetInheritedFactory(_ArrayLayoutWidget)))(t || _ArrayLayoutWidget);
  };
})();
_ArrayLayoutWidget.ɵdir = ɵɵdefineDirective({
  type: _ArrayLayoutWidget,
  features: [ɵɵInheritDefinitionFeature]
});
var ArrayLayoutWidget = _ArrayLayoutWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ArrayLayoutWidget, [{
    type: Directive
  }], null, null);
})();
var _ObjectLayoutWidget = class _ObjectLayoutWidget extends Widget {
  reset(_value) {
  }
  afterViewInit() {
  }
  ngAfterViewInit() {
    this.formProperty.errorsChanges.pipe(takeUntil(this.sfItemComp.destroy$)).subscribe(() => this.cd.detectChanges());
  }
};
_ObjectLayoutWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵObjectLayoutWidget_BaseFactory;
  return function ObjectLayoutWidget_Factory(t) {
    return (ɵObjectLayoutWidget_BaseFactory || (ɵObjectLayoutWidget_BaseFactory = ɵɵgetInheritedFactory(_ObjectLayoutWidget)))(t || _ObjectLayoutWidget);
  };
})();
_ObjectLayoutWidget.ɵdir = ɵɵdefineDirective({
  type: _ObjectLayoutWidget,
  features: [ɵɵInheritDefinitionFeature]
});
var ObjectLayoutWidget = _ObjectLayoutWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObjectLayoutWidget, [{
    type: Directive
  }], null, null);
})();
var _ArrayWidget = class _ArrayWidget extends ArrayLayoutWidget {
  constructor() {
    super(...arguments);
    this.arraySpan = 8;
  }
  get addDisabled() {
    return this.disabled || this.schema.maxItems != null && this.formProperty.properties.length >= this.schema.maxItems;
  }
  get showRemove() {
    if (this.disabled || !this.removeTitle)
      return false;
    if (this.schema.minItems != null && this.formProperty.properties.length <= this.schema.minItems)
      return false;
    return true;
  }
  ngOnInit() {
    const {
      grid,
      addTitle,
      addType,
      removable,
      removeTitle
    } = this.ui;
    if (grid && grid.arraySpan) {
      this.arraySpan = grid.arraySpan;
    }
    this.addTitle = this.dom.bypassSecurityTrustHtml(addTitle || this.l.addText);
    this.addType = addType || "dashed";
    this.removeTitle = removable === false ? null : removeTitle || this.l.removeText;
  }
  reValid(options) {
    this.formProperty.updateValueAndValidity(__spreadValues({
      onlySelf: false,
      emitValueEvent: false,
      emitValidator: true
    }, options));
  }
  addItem() {
    const property = this.formProperty.add({});
    this.reValid();
    this.ui.add?.(property);
  }
  removeItem(index) {
    const updatePath = this.formProperty.properties[index].path;
    this.formProperty.remove(index);
    this.reValid({
      updatePath,
      emitValueEvent: true
    });
    this.ui.remove?.(index);
  }
};
_ArrayWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵArrayWidget_BaseFactory;
  return function ArrayWidget_Factory(t) {
    return (ɵArrayWidget_BaseFactory || (ɵArrayWidget_BaseFactory = ɵɵgetInheritedFactory(_ArrayWidget)))(t || _ArrayWidget);
  };
})();
_ArrayWidget.ɵcmp = ɵɵdefineComponent({
  type: _ArrayWidget,
  selectors: [["sf-array"]],
  hostVars: 2,
  hostBindings: function ArrayWidget_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("sf__array", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 8,
  vars: 10,
  consts: [["nz-col", "", "class", "ant-form-item-label", 3, "nzSpan"], ["nz-col", "", 1, "ant-form-item-control-wrapper", 3, "nzSpan", "nzOffset"], [1, "ant-form-item-control"], ["nz-row", "", 1, "sf__array-container"], [4, "ngFor", "ngForOf"], ["class", "ant-form-explain"], ["class", "ant-form-extra", 3, "innerHTML"], ["nz-col", "", 1, "ant-form-item-label", 3, "nzSpan"], [1, "sf__optional"], ["nz-tooltip", "", "nz-icon", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [1, "sf__array-add"], ["type", "button", "nz-button", "", 3, "nzType", "disabled", "innerHTML", "click"], ["nz-col", "", "class", "sf__array-item", 3, "nzSpan"], ["nz-col", "", 1, "sf__array-item", 3, "nzSpan"], [3, "formProperty"], ["class", "sf__array-remove"], [1, "sf__array-remove", 3, "click"], ["nz-icon", "", "nzType", "delete"], [1, "ant-form-explain"], [1, "ant-form-extra", 3, "innerHTML"]],
  template: function ArrayWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nz-form-item");
      ɵɵtemplate(1, ArrayWidget_Conditional_1_Template, 8, 9, "div", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      ɵɵtemplate(5, ArrayWidget_ng_container_5_Template, 2, 1, "ng-container", 4);
      ɵɵelementEnd();
      ɵɵtemplate(6, ArrayWidget_Conditional_6_Template, 2, 1, "div", 5)(7, ArrayWidget_Conditional_7_Template, 1, 1, "div", 6);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵclassProp("ant-form-item-with-help", ctx.showError);
      ɵɵadvance();
      ɵɵconditional(1, ctx.schema.title ? 1 : -1);
      ɵɵadvance();
      ɵɵproperty("nzSpan", ctx.ui.spanControl)("nzOffset", ctx.ui.offsetControl);
      ɵɵadvance();
      ɵɵclassProp("has-error", ctx.showError);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.formProperty.properties);
      ɵɵadvance();
      ɵɵconditional(6, !ctx.ui.onlyVisual && ctx.showError ? 6 : -1);
      ɵɵadvance();
      ɵɵconditional(7, ctx.schema.description ? 7 : -1);
    }
  },
  dependencies: [NgForOf, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, NzCardComponent, NzColDirective, NzRowDirective, NzFormItemComponent, NzIconDirective, NzTooltipDirective, SFItemComponent],
  encapsulation: 2
});
var ArrayWidget = _ArrayWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ArrayWidget, [{
    type: Component,
    args: [{
      selector: "sf-array",
      template: `<nz-form-item [class.ant-form-item-with-help]="showError">
    @if (schema.title) {
      <div nz-col [nzSpan]="ui.spanLabel!" class="ant-form-item-label">
        <label [class.ant-form-item-required]="ui.required">
          {{ schema.title }}
          <span class="sf__optional">
            {{ ui.optional }}
            @if (oh) {
              <i
                nz-tooltip
                [nzTooltipTitle]="oh.text"
                [nzTooltipPlacement]="oh.placement"
                [nzTooltipTrigger]="oh.trigger"
                [nzTooltipOverlayClassName]="oh.overlayClassName"
                [nzTooltipOverlayStyle]="oh.overlayStyle"
                [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                nz-icon
                [nzType]="oh.icon!"
              ></i>
            }
          </span>
        </label>
        <div class="sf__array-add">
          <button
            type="button"
            nz-button
            [nzType]="addType"
            [disabled]="addDisabled"
            (click)="addItem()"
            [innerHTML]="addTitle"
          ></button>
        </div>
      </div>
    }
    <div nz-col class="ant-form-item-control-wrapper" [nzSpan]="ui.spanControl!" [nzOffset]="ui.offsetControl!">
      <div class="ant-form-item-control" [class.has-error]="showError">
        <div nz-row class="sf__array-container">
          <ng-container *ngFor="let i of $any(formProperty).properties; let $index = index">
            @if (i.visible && !i.ui.hidden) {
              <div nz-col [nzSpan]="arraySpan" [attr.data-index]="$index" class="sf__array-item">
                <nz-card>
                  <sf-item [formProperty]="i" />
                  @if (showRemove) {
                    <span class="sf__array-remove" (click)="removeItem($index)" [attr.title]="removeTitle">
                      <i nz-icon nzType="delete"></i>
                    </span>
                  }
                </nz-card>
              </div>
            }
          </ng-container>
        </div>
        @if (!ui.onlyVisual && showError) {
          <div class="ant-form-explain">{{ error }}</div>
        }
        @if (schema.description) {
          <div [innerHTML]="ui._description" class="ant-form-extra"></div>
        }
      </div>
    </div>
  </nz-form-item>`,
      host: {
        "[class.sf__array]": "true"
      },
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _BooleanWidget = class _BooleanWidget extends ControlUIWidget {
};
_BooleanWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵBooleanWidget_BaseFactory;
  return function BooleanWidget_Factory(t) {
    return (ɵBooleanWidget_BaseFactory || (ɵBooleanWidget_BaseFactory = ɵɵgetInheritedFactory(_BooleanWidget)))(t || _BooleanWidget);
  };
})();
_BooleanWidget.ɵcmp = ɵɵdefineComponent({
  type: _BooleanWidget,
  selectors: [["sf-boolean"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 12,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "ngModel", "nzDisabled", "nzSize", "nzCheckedChildren", "nzUnCheckedChildren", "nzLoading", "ngModelChange"]],
  template: function BooleanWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "sf-item-wrap", 0)(1, "nz-switch", 1);
      ɵɵlistener("ngModelChange", function BooleanWidget_Template_nz_switch_ngModelChange_1_listener($event) {
        return ctx.setValue($event);
      });
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      ɵɵadvance();
      ɵɵproperty("ngModel", ctx.value)("nzDisabled", ctx.disabled)("nzSize", ctx.ui.size)("nzCheckedChildren", ctx.ui.checkedChildren)("nzUnCheckedChildren", ctx.ui.unCheckedChildren)("nzLoading", ctx.ui.loading);
    }
  },
  dependencies: [NgControlStatus, NgModel, NzSwitchComponent, SFItemWrapComponent],
  encapsulation: 2
});
var BooleanWidget = _BooleanWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanWidget, [{
    type: Component,
    args: [{
      selector: "sf-boolean",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-switch
      [ngModel]="value"
      (ngModelChange)="setValue($event)"
      [nzDisabled]="disabled"
      [nzSize]="ui.size!"
      [nzCheckedChildren]="ui.checkedChildren!"
      [nzUnCheckedChildren]="ui.unCheckedChildren!"
      [nzLoading]="ui.loading"
    />
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _CheckboxWidget = class _CheckboxWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.data = [];
    this.allChecked = false;
    this.indeterminate = false;
    this.labelTitle = ``;
    this.inited = false;
  }
  reset(value) {
    this.inited = false;
    getData(this.schema, this.ui, value).subscribe((list) => {
      this.data = list;
      this.allChecked = false;
      this.indeterminate = false;
      this.labelTitle = list.length === 0 ? "" : this.schema.title;
      const {
        span
      } = this.ui;
      this.grid_span = span && span > 0 ? span : 0;
      this.updateAllChecked();
      this.inited = true;
      this.detectChanges();
    });
  }
  _setValue(value) {
    this.setValue(value);
    this.detectChanges();
    this.notifyChange(value);
  }
  notifySet() {
    const checkList = this.data.filter((w) => w.checked);
    this.updateAllChecked().setValue(checkList.map((item) => item.value));
    this.notifyChange(checkList);
  }
  groupInGridChange(values) {
    this.data.forEach((item) => item.checked = values.indexOf(item.value) !== -1);
    this.notifySet();
  }
  onAllChecked() {
    this.data.forEach((item) => item.checked = this.allChecked);
    this.notifySet();
  }
  updateAllChecked() {
    if (this.data.every((item) => item.checked !== true)) {
      this.allChecked = false;
      this.indeterminate = false;
    } else if (this.data.every((item) => item.checked === true)) {
      this.allChecked = true;
      this.indeterminate = false;
    } else {
      this.indeterminate = true;
    }
    this.detectChanges();
    return this;
  }
  notifyChange(res) {
    if (this.ui.change)
      this.ui.change(res);
  }
};
_CheckboxWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵCheckboxWidget_BaseFactory;
  return function CheckboxWidget_Factory(t) {
    return (ɵCheckboxWidget_BaseFactory || (ɵCheckboxWidget_BaseFactory = ɵɵgetInheritedFactory(_CheckboxWidget)))(t || _CheckboxWidget);
  };
})();
_CheckboxWidget.ɵcmp = ɵɵdefineComponent({
  type: _CheckboxWidget,
  selectors: [["sf-checkbox"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 4,
  vars: 8,
  consts: [["all", ""], [3, "id", "schema", "ui", "showError", "error", "showTitle", "title"], ["nz-checkbox", "", "class", "sf__checkbox-all mr-sm", 3, "ngModel", "nzIndeterminate"], ["nz-checkbox", "", 1, "sf__checkbox-all", "mr-sm", 3, "ngModel", "nzIndeterminate", "ngModelChange"], ["nz-checkbox", "", 3, "nzDisabled", "ngModel"], ["nz-checkbox", "", 3, "nzDisabled", "ngModel", "ngModelChange"], [1, "sf__optional"], ["nz-tooltip", "", "nz-icon", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [3, "ngTemplateOutlet"], [3, "ngModel", "ngModelChange"], [1, "sf__checkbox-list", 3, "nzOnChange"], ["nz-row", ""], ["nz-col", "", 3, "nzSpan"], ["nz-checkbox", "", 3, "nzValue", "ngModel", "nzDisabled"]],
  template: function CheckboxWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CheckboxWidget_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      ɵɵelementStart(2, "sf-item-wrap", 1);
      ɵɵtemplate(3, CheckboxWidget_Conditional_3_Template, 2, 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", true)("title", ctx.labelTitle);
      ɵɵadvance();
      ɵɵconditional(3, ctx.inited ? 3 : -1);
    }
  },
  dependencies: [NgTemplateOutlet, NgControlStatus, NgModel, NzTransitionPatchDirective, NzCheckboxComponent, NzCheckboxGroupComponent, NzCheckboxWrapperComponent, NzColDirective, NzRowDirective, NzIconDirective, NzTooltipDirective, SFItemWrapComponent],
  encapsulation: 2
});
var CheckboxWidget = _CheckboxWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxWidget, [{
    type: Component,
    args: [{
      selector: "sf-checkbox",
      template: `<ng-template #all>
      @if (ui.checkAll) {
        <label
          nz-checkbox
          class="sf__checkbox-all mr-sm"
          [(ngModel)]="allChecked"
          (ngModelChange)="onAllChecked()"
          [nzIndeterminate]="indeterminate"
        >
          {{ ui.checkAllText || l.checkAllText }}
        </label>
      }
    </ng-template>
    <sf-item-wrap
      [id]="id"
      [schema]="schema"
      [ui]="ui"
      [showError]="showError"
      [error]="error"
      [showTitle]="true"
      [title]="labelTitle"
    >
      @if (inited) {
        @if (data.length === 0) {
          <label nz-checkbox [nzDisabled]="disabled" [ngModel]="value" (ngModelChange)="_setValue($event)">
            {{ schema.title }}
            <span class="sf__optional">
              {{ ui.optional }}
              @if (oh) {
                <i
                  nz-tooltip
                  [nzTooltipTitle]="oh.text"
                  [nzTooltipPlacement]="oh.placement"
                  [nzTooltipTrigger]="oh.trigger"
                  [nzTooltipOverlayClassName]="oh.overlayClassName"
                  [nzTooltipOverlayStyle]="oh.overlayStyle"
                  [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                  [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                  nz-icon
                  [nzType]="oh.icon!"
                ></i>
              }
            </span>
          </label>
        } @else {
          @if (grid_span === 0) {
            <ng-template [ngTemplateOutlet]="all" />
            <nz-checkbox-group [ngModel]="data" (ngModelChange)="notifySet()" />
          } @else {
            <nz-checkbox-wrapper class="sf__checkbox-list" (nzOnChange)="groupInGridChange($event)">
              <div nz-row>
                @if (ui.checkAll) {
                  <div nz-col [nzSpan]="grid_span">
                    <ng-template [ngTemplateOutlet]="all" />
                  </div>
                }
                @for (i of data; track $index) {
                  <div nz-col [nzSpan]="grid_span">
                    <label nz-checkbox [nzValue]="i.value" [ngModel]="i.checked" [nzDisabled]="i.disabled">
                      {{ i.label }}
                    </label>
                  </div>
                }
              </div>
            </nz-checkbox-wrapper>
          }
        }
      }
    </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _CustomWidget = class _CustomWidget extends ControlUIWidget {
};
_CustomWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵCustomWidget_BaseFactory;
  return function CustomWidget_Factory(t) {
    return (ɵCustomWidget_BaseFactory || (ɵCustomWidget_BaseFactory = ɵɵgetInheritedFactory(_CustomWidget)))(t || _CustomWidget);
  };
})();
_CustomWidget.ɵcmp = ɵɵdefineComponent({
  type: _CustomWidget,
  selectors: [["sf-custom"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 12,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function CustomWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "sf-item-wrap", 0);
      ɵɵtemplate(1, CustomWidget_ng_template_1_Template, 0, 0, "ng-template", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.ui._render)("ngTemplateOutletContext", ɵɵpureFunction3(8, _c2, ctx, ctx.schema, ctx.ui));
    }
  },
  dependencies: [NgTemplateOutlet, SFItemWrapComponent],
  encapsulation: 2
});
var CustomWidget = _CustomWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomWidget, [{
    type: Component,
    args: [{
      selector: "sf-custom",
      template: `
    <sf-item-wrap
      [id]="id"
      [schema]="schema"
      [ui]="ui"
      [showError]="showError"
      [error]="error"
      [showTitle]="schema.title"
    >
      <ng-template
        [ngTemplateOutlet]="$any(ui)._render"
        [ngTemplateOutletContext]="{ $implicit: this, schema: schema, ui: ui }"
      />
    </sf-item-wrap>
  `,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _DateWidget = class _DateWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.flatRange = false;
    this.displayValue = null;
  }
  ngOnInit() {
    const {
      mode,
      end,
      displayFormat,
      allowClear,
      showToday
    } = this.ui;
    this.mode = mode || "date";
    this.flatRange = end != null;
    this.startFormat = this.ui._format;
    if (this.flatRange) {
      this.mode = "range";
      const endUi = this.endProperty.ui;
      this.endFormat = endUi.format ? endUi._format : this.startFormat;
    }
    if (!displayFormat) {
      switch (this.mode) {
        case "year":
          this.displayFormat = `yyyy`;
          break;
        case "month":
          this.displayFormat = `yyyy-MM`;
          break;
        case "week":
          this.displayFormat = `yyyy-ww`;
          break;
      }
    } else {
      this.displayFormat = displayFormat;
    }
    this.i = {
      allowClear: toBool(allowClear, true),
      // nz-date-picker
      showToday: toBool(showToday, true)
    };
  }
  reset(value) {
    const toDateOptions = {
      formatString: this.startFormat,
      defaultValue: null
    };
    if (Array.isArray(value)) {
      value = value.map((v) => toDate(v, toDateOptions));
    } else {
      value = toDate(value, toDateOptions);
    }
    if (this.flatRange) {
      const endValue = toDate(this.endProperty.formData, {
        formatString: this.endFormat || this.startFormat,
        defaultValue: null
      });
      this.displayValue = value == null || endValue == null ? [] : [value, endValue];
    } else {
      this.displayValue = value;
    }
    this.detectChanges();
    if (this.displayValue) {
      setTimeout(() => this._change(this.displayValue, false));
    }
  }
  _change(value, emitModelChange = true) {
    if (emitModelChange && this.ui.change) {
      this.ui.change(value);
    }
    if (value == null || Array.isArray(value) && value.length < 2) {
      this.setValue(null);
      this.setEnd(null);
      return;
    }
    const res = Array.isArray(value) ? [format(value[0], this.startFormat), format(value[1], this.endFormat || this.startFormat)] : format(value, this.startFormat);
    if (this.flatRange) {
      this.setValue(res[0]);
      this.setEnd(res[1]);
    } else {
      this.setValue(res);
    }
  }
  _openChange(status) {
    if (this.ui.onOpenChange)
      this.ui.onOpenChange(status);
  }
  _ok(value) {
    if (this.ui.onOk)
      this.ui.onOk(value);
  }
  get endProperty() {
    return this.formProperty.parent.properties[this.ui.end];
  }
  setEnd(value) {
    if (!this.flatRange)
      return;
    this.endProperty.setValue(value, true);
    this.endProperty.updateValueAndValidity();
  }
};
_DateWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵDateWidget_BaseFactory;
  return function DateWidget_Factory(t) {
    return (ɵDateWidget_BaseFactory || (ɵDateWidget_BaseFactory = ɵɵgetInheritedFactory(_DateWidget)))(t || _DateWidget);
  };
})();
_DateWidget.ɵcmp = ɵɵdefineComponent({
  type: _DateWidget,
  selectors: [["sf-date"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 6,
  vars: 7,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "ngClass", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzRenderExtraFooter", "nzInputReadOnly", "nzInline", "ngModelChange", "nzOnOpenChange"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "ngClass", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzInputReadOnly", "nzInline", "ngModelChange", "nzOnOpenChange"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "ngClass", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzDisabledTime", "nzRenderExtraFooter", "nzRanges", "nzShowTime", "nzSeparator", "nzShowWeekNumber", "nzMode", "nzInputReadOnly", "nzInline", "ngModelChange", "nzOnOpenChange", "nzOnOk"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "ngClass", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzDisabledTime", "nzRenderExtraFooter", "nzShowTime", "nzShowToday", "nzShowWeekNumber", "nzInputReadOnly", "nzInline", "ngModelChange", "nzOnOpenChange", "nzOnOk"]],
  template: function DateWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "sf-item-wrap", 0);
      ɵɵtemplate(1, DateWidget_Case_1_Template, 1, 15)(2, DateWidget_Case_2_Template, 1, 15)(3, DateWidget_Case_3_Template, 1, 14)(4, DateWidget_Case_4_Template, 1, 21)(5, DateWidget_Case_5_Template, 1, 19);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      let DateWidget_contFlowTmp;
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      ɵɵadvance();
      ɵɵconditional(1, (DateWidget_contFlowTmp = ctx.mode) === "year" ? 1 : DateWidget_contFlowTmp === "month" ? 2 : DateWidget_contFlowTmp === "week" ? 3 : DateWidget_contFlowTmp === "range" ? 4 : 5);
    }
  },
  dependencies: [NgClass, NgControlStatus, NgModel, NzDatePickerComponent, NzRangePickerComponent, NzMonthPickerComponent, NzYearPickerComponent, NzWeekPickerComponent, SFItemWrapComponent],
  encapsulation: 2
});
var DateWidget = _DateWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateWidget, [{
    type: Component,
    args: [{
      selector: "sf-date",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    @switch (mode) {
      @case ('year') {
        <nz-year-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
        />
      }
      @case ('month') {
        <nz-month-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
        />
      }
      @case ('week') {
        <nz-week-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
          (nzOnOpenChange)="_openChange($event)"
        />
      }
      @case ('range') {
        <nz-range-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzDisabledTime]="ui.disabledTime"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzRanges]="ui.ranges"
          [nzShowTime]="ui.showTime"
          [nzSeparator]="ui.separator"
          [nzShowWeekNumber]="ui.showWeekNumber || false"
          [nzMode]="ui.rangeMode"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
          (nzOnOk)="_ok($event)"
        />
      }
      @default {
        <nz-date-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [ngClass]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzDisabledTime]="ui.disabledTime"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzShowTime]="ui.showTime"
          [nzShowToday]="i.showToday"
          [nzShowWeekNumber]="ui.showWeekNumber || false"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
          (nzOnOk)="_ok($event)"
        />
      }
    }
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _NumberWidget = class _NumberWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.formatter = (value) => value;
    this.parser = (value) => value;
    this.width = "";
  }
  ngOnInit() {
    const {
      minimum,
      exclusiveMinimum,
      maximum,
      exclusiveMaximum,
      multipleOf,
      type
    } = this.schema;
    this.step = multipleOf || 1;
    if (typeof minimum !== "undefined") {
      this.min = exclusiveMinimum ? minimum + this.step : minimum;
    }
    if (typeof maximum !== "undefined") {
      this.max = exclusiveMaximum ? maximum - this.step : maximum;
    }
    if (type === "integer") {
      this.min = Math.trunc(this.min);
      this.max = Math.trunc(this.max);
      this.step = Math.trunc(this.step);
    }
    const ui = this.ui;
    if (ui.prefix != null) {
      ui.formatter = (value) => value == null ? "" : `${ui.prefix} ${value}`;
      ui.parser = (value) => value.replace(`${ui.prefix} `, "");
    }
    if (ui.unit != null) {
      ui.formatter = (value) => value == null ? "" : `${value} ${ui.unit}`;
      ui.parser = (value) => value.replace(` ${ui.unit}`, "");
    }
    if (ui.formatter)
      this.formatter = ui.formatter;
    if (ui.parser)
      this.parser = ui.parser;
    this.width = typeof ui.widgetWidth === "number" ? `${ui.widgetWidth}px` : ui.widgetWidth ?? "90px";
  }
  _setValue(val) {
    this.setValue(this.schema.type === "integer" ? Math.floor(val) : val);
    if (this.ui.change)
      this.ui.change(this.value);
  }
};
_NumberWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵNumberWidget_BaseFactory;
  return function NumberWidget_Factory(t) {
    return (ɵNumberWidget_BaseFactory || (ɵNumberWidget_BaseFactory = ɵɵgetInheritedFactory(_NumberWidget)))(t || _NumberWidget);
  };
})();
_NumberWidget.ɵcmp = ɵɵdefineComponent({
  type: _NumberWidget,
  selectors: [["sf-number"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 22,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzId", "ngModel", "nzDisabled", "nzSize", "nzMin", "nzMax", "nzStep", "nzFormatter", "nzParser", "nzPrecision", "nzPlaceHolder", "ngClass", "ngModelChange"]],
  template: function NumberWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "sf-item-wrap", 0)(1, "nz-input-number", 1);
      ɵɵlistener("ngModelChange", function NumberWidget_Template_nz_input_number_ngModelChange_1_listener($event) {
        return ctx._setValue($event);
      });
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      ɵɵadvance();
      ɵɵstyleProp("width", ctx.width);
      ɵɵproperty("nzId", ctx.id)("ngModel", ctx.value)("nzDisabled", ctx.disabled)("nzSize", ctx.ui.size)("nzMin", ctx.min)("nzMax", ctx.max)("nzStep", ctx.step)("nzFormatter", ctx.formatter)("nzParser", ctx.parser)("nzPrecision", ctx.ui.precision)("nzPlaceHolder", ctx.ui.placeholder || "")("ngClass", ɵɵpureFunction1(20, _c3, ctx.ui.hideStep));
    }
  },
  dependencies: [NgClass, NgControlStatus, NgModel, NzInputNumberComponent, SFItemWrapComponent],
  encapsulation: 2
});
var NumberWidget = _NumberWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberWidget, [{
    type: Component,
    args: [{
      selector: "sf-number",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-input-number
      [nzId]="id"
      [ngModel]="value"
      (ngModelChange)="_setValue($event)"
      [nzDisabled]="disabled"
      [nzSize]="ui.size!"
      [nzMin]="min"
      [nzMax]="max"
      [nzStep]="step"
      [nzFormatter]="formatter"
      [nzParser]="parser"
      [nzPrecision]="ui.precision"
      [nzPlaceHolder]="ui.placeholder || ''"
      [style.width]="width"
      [ngClass]="{ 'ant-input-number__hide-step': ui.hideStep }"
    />
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _ObjectWidget = class _ObjectWidget extends ObjectLayoutWidget {
  constructor() {
    super(...arguments);
    this.type = "default";
    this.list = [];
    this.showExpand = true;
    this.expand = true;
  }
  ngOnInit() {
    const {
      formProperty,
      ui
    } = this;
    const {
      grid,
      showTitle,
      type
    } = ui;
    this.showExpand = toBool(ui.showExpand, true);
    this.expand = toBool(ui.expand, true);
    this.type = type ?? "default";
    if (this.type === "card" || !formProperty.isRoot() && !(formProperty.parent instanceof ArrayProperty) && showTitle === true) {
      this.title = this.schema.title;
    }
    this.grid = grid;
    const list = [];
    for (const key of formProperty.propertiesId) {
      const property = formProperty.properties[key];
      const item = {
        property,
        grid: property.ui.grid || grid || {},
        spanLabelFixed: property.ui.spanLabelFixed,
        show: property.ui.hidden === false
      };
      list.push(item);
    }
    this.list = list;
  }
  changeExpand() {
    if (!this.showExpand) {
      return;
    }
    this.expand = !this.expand;
    this.detectChanges(true);
  }
};
_ObjectWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵObjectWidget_BaseFactory;
  return function ObjectWidget_Factory(t) {
    return (ɵObjectWidget_BaseFactory || (ɵObjectWidget_BaseFactory = ɵɵgetInheritedFactory(_ObjectWidget)))(t || _ObjectWidget);
  };
})();
_ObjectWidget.ɵcmp = ɵɵdefineComponent({
  type: _ObjectWidget,
  selectors: [["sf-object"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 4,
  vars: 1,
  consts: [["default", ""], ["class", "sf__object-card", 3, "nzTitle", "nzExtra", "nzSize", "nzActions", "nzBodyStyle", "nzBordered", "nzBorderless", "sf__object-card-fold"], ["class", "sf__title"], ["nz-row", "", 3, "nzGutter"], [1, "sf__title"], ["nz-col", "", 3, "nzSpan", "nzOffset", "nzXs", "nzSm", "nzMd", "nzLg", "nzXl", "nzXXl"], [3, "formProperty", "fixed-label"], [1, "sf__object-card", 3, "nzTitle", "nzExtra", "nzSize", "nzActions", "nzBodyStyle", "nzBordered", "nzBorderless"], ["cardTitleTpl", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "click"], ["nz-icon", "", "class", "mr-xs text-xs", 3, "nzType"], ["class", "sf__optional"], ["nz-icon", "", 1, "mr-xs", "text-xs", 3, "nzType"], [1, "sf__optional"], ["s", "", "nz-tooltip", "", "nz-icon", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipColor", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [3, "ngTemplateOutlet"]],
  template: function ObjectWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ObjectWidget_ng_template_0_Template, 3, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, ObjectWidget_Conditional_2_Template, 4, 13, "nz-card", 1)(3, ObjectWidget_Conditional_3_Template, 1, 1);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵconditional(2, ctx.type === "card" ? 2 : 3);
    }
  },
  dependencies: [NgTemplateOutlet, NzTransitionPatchDirective, NzCardComponent, NzColDirective, NzRowDirective, NzIconDirective, NzTooltipDirective, SFItemComponent, SFFixedDirective],
  encapsulation: 2
});
var ObjectWidget = _ObjectWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObjectWidget, [{
    type: Component,
    args: [{
      selector: "sf-object",
      template: `<ng-template #default let-noTitle>
      @if (!noTitle && title) {
        <div class="sf__title">{{ title }}</div>
      }
      @if (grid) {
        <div nz-row [nzGutter]="grid.gutter">
          @for (i of list; track $index) {
            @if (i.property.visible && i.show) {
              <div
                nz-col
                [nzSpan]="i.grid.span"
                [nzOffset]="i.grid.offset"
                [nzXs]="i.grid.xs"
                [nzSm]="i.grid.sm"
                [nzMd]="i.grid.md"
                [nzLg]="i.grid.lg"
                [nzXl]="i.grid.xl"
                [nzXXl]="i.grid.xxl"
              >
                <sf-item [formProperty]="i.property" [fixed-label]="i.spanLabelFixed" />
              </div>
            }
          }
        </div>
      } @else {
        @for (i of list; track $index) {
          @if (i.property.visible && i.show) {
            <sf-item [formProperty]="i.property" [fixed-label]="i.spanLabelFixed" />
          }
        }
      }
    </ng-template>
    @if (type === 'card') {
      <nz-card
        [nzTitle]="cardTitleTpl"
        [nzExtra]="ui.cardExtra"
        [nzSize]="ui.cardSize || 'small'"
        [nzActions]="ui.cardActions || []"
        [nzBodyStyle]="ui.cardBodyStyle!"
        [nzBordered]="ui.cardBordered || true"
        [nzBorderless]="ui.cardBorderless || false"
        class="sf__object-card"
        [class.sf__object-card-fold]="!expand"
      >
        <ng-template #cardTitleTpl>
          <div [class.point]="showExpand" (click)="changeExpand()">
            @if (showExpand) {
              <i nz-icon [nzType]="expand ? 'down' : 'up'" class="mr-xs text-xs"></i>
            }
            {{ title }}
            @if (ui.optional || oh) {
              <span class="sf__optional">
                {{ ui.optional }}
                @if (oh) {
                  <i
                    s
                    nz-tooltip
                    [nzTooltipTitle]="oh.text"
                    [nzTooltipPlacement]="oh.placement"
                    [nzTooltipTrigger]="oh.trigger"
                    [nzTooltipColor]="oh.bgColor"
                    [nzTooltipOverlayClassName]="oh.overlayClassName"
                    [nzTooltipOverlayStyle]="oh.overlayStyle"
                    [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                    [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                    nz-icon
                    [nzType]="oh.icon!"
                  ></i>
                }
              </span>
            }
          </div>
        </ng-template>
        <ng-template [ngTemplateOutlet]="default" [ngTemplateOutletContext]="{ $implicit: true }" />
      </nz-card>
    } @else {
      <ng-template [ngTemplateOutlet]="default" />
    }`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _RadioWidget = class _RadioWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  reset(value) {
    this.styleType = (this.ui.styleType || "default") === "default";
    getData(this.schema, this.ui, value).subscribe((list) => {
      this.data = list;
      this.detectChanges();
    });
  }
  _setValue(value) {
    this.setValue(value);
    if (this.ui.change)
      this.ui.change(value);
  }
};
_RadioWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵRadioWidget_BaseFactory;
  return function RadioWidget_Factory(t) {
    return (ɵRadioWidget_BaseFactory || (ɵRadioWidget_BaseFactory = ɵɵgetInheritedFactory(_RadioWidget)))(t || _RadioWidget);
  };
})();
_RadioWidget.ɵcmp = ɵɵdefineComponent({
  type: _RadioWidget,
  selectors: [["sf-radio"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 4,
  vars: 11,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzSize", "nzName", "ngModel", "nzButtonStyle", "ngModelChange"], ["nz-radio", "", 3, "nzValue", "nzDisabled"], [3, "innerHTML"], ["nz-radio-button", "", 3, "nzValue", "nzDisabled"]],
  template: function RadioWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "sf-item-wrap", 0)(1, "nz-radio-group", 1);
      ɵɵlistener("ngModelChange", function RadioWidget_Template_nz_radio_group_ngModelChange_1_listener($event) {
        return ctx._setValue($event);
      });
      ɵɵtemplate(2, RadioWidget_Conditional_2_Template, 2, 0)(3, RadioWidget_Conditional_3_Template, 2, 0);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      ɵɵadvance();
      ɵɵproperty("nzSize", ctx.ui.size)("nzName", ctx.id)("ngModel", ctx.value)("nzButtonStyle", ctx.ui.buttonStyle || "outline");
      ɵɵadvance();
      ɵɵconditional(2, ctx.styleType ? 2 : 3);
    }
  },
  dependencies: [NgControlStatus, NgModel, NzRadioComponent, NzRadioButtonDirective, NzRadioGroupComponent, SFItemWrapComponent],
  encapsulation: 2
});
var RadioWidget = _RadioWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioWidget, [{
    type: Component,
    args: [{
      selector: "sf-radio",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-radio-group
      [nzSize]="ui.size!"
      [nzName]="id"
      [ngModel]="value"
      (ngModelChange)="_setValue($event)"
      [nzButtonStyle]="ui.buttonStyle || 'outline'"
    >
      @if (styleType) {
        @for (option of data; track $index) {
          <label nz-radio [nzValue]="option.value" [nzDisabled]="disabled || option.disabled">
            <span [innerHTML]="option.label"></span>
          </label>
        }
      } @else {
        @for (option of data; track $index) {
          <label nz-radio-button [nzValue]="option.value" [nzDisabled]="disabled || option.disabled">
            <span [innerHTML]="option.label"></span>
          </label>
        }
      }
    </nz-radio-group>
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _SelectWidget = class _SelectWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.search$ = new Subject();
    this.data = [];
    this.hasGroup = false;
    this.loading = false;
  }
  checkGroup(list) {
    this.hasGroup = (list || []).filter((w) => w.group === true).length > 0;
  }
  ngOnInit() {
    const {
      autoClearSearchValue,
      borderless,
      autoFocus,
      dropdownMatchSelectWidth,
      serverSearch,
      maxMultipleCount,
      mode,
      showSearch,
      tokenSeparators,
      maxTagCount,
      compareWith,
      optionHeightPx,
      optionOverflowSize,
      showArrow
    } = this.ui;
    this.i = {
      autoClearSearchValue: toBool(autoClearSearchValue, true),
      borderless: toBool(borderless, false),
      autoFocus: toBool(autoFocus, false),
      dropdownMatchSelectWidth: toBool(dropdownMatchSelectWidth, true),
      serverSearch: toBool(serverSearch, false),
      maxMultipleCount: maxMultipleCount || Infinity,
      mode: mode || "default",
      showSearch: toBool(showSearch, true),
      tokenSeparators: tokenSeparators || [],
      maxTagCount: maxTagCount || void 0,
      optionHeightPx: optionHeightPx || 32,
      optionOverflowSize: optionOverflowSize || 8,
      showArrow: typeof showArrow !== "boolean" ? void 0 : showArrow,
      compareWith: compareWith || ((o1, o2) => o1 === o2)
    };
    const onSearch = this.ui.onSearch;
    if (onSearch) {
      this.search$.pipe(takeUntil(this.sfItemComp.destroy$), distinctUntilChanged(), debounceTime(this.ui.searchDebounceTime || 300), switchMap((text) => onSearch(text)), catchError(() => [])).subscribe((list) => {
        this.data = list;
        this.checkGroup(list);
        this.loading = false;
        this.detectChanges();
      });
    }
  }
  reset(value) {
    const onSearch = this.ui.onSearch;
    getData(this.schema, this.ui, value).subscribe((list) => {
      this._value = value;
      if (onSearch == null)
        this.data = list;
      this.checkGroup(list);
      this.detectChanges();
    });
    if (value && onSearch != null)
      this.search$.next(value);
  }
  change(values) {
    if (this.ui.change) {
      this.ui.change(values, this.getOrgData(values));
    }
    this.setValue(values == null ? void 0 : values);
  }
  getOrgData(values) {
    const srv = this.injector.get(ArrayService);
    if (!Array.isArray(values)) {
      return srv.findTree(this.data, (item) => item.value === values);
    }
    return values.map((value) => srv.findTree(this.data, (item) => item.value === value));
  }
  openChange(status) {
    if (this.ui.openChange) {
      this.ui.openChange(status);
    }
  }
  scrollToBottom() {
    if (this.ui.scrollToBottom) {
      this.ui.scrollToBottom();
    }
  }
  onSearch(value) {
    if (this.ui.onSearch) {
      this.loading = true;
      this.search$.next(value);
    }
  }
};
_SelectWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵSelectWidget_BaseFactory;
  return function SelectWidget_Factory(t) {
    return (ɵSelectWidget_BaseFactory || (ɵSelectWidget_BaseFactory = ɵɵgetInheritedFactory(_SelectWidget)))(t || _SelectWidget);
  };
})();
_SelectWidget.ɵcmp = ɵɵdefineComponent({
  type: _SelectWidget,
  selectors: [["sf-select"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 5,
  vars: 39,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzId", "nzDisabled", "ngModel", "nzSize", "nzPlaceHolder", "nzNotFoundContent", "nzDropdownClassName", "nzAllowClear", "nzDropdownStyle", "nzCustomTemplate", "nzSuffixIcon", "nzRemoveIcon", "nzClearIcon", "nzMenuItemSelectedIcon", "nzMaxTagPlaceholder", "nzDropdownRender", "nzAutoClearSearchValue", "nzBorderless", "nzAutoFocus", "nzDropdownMatchSelectWidth", "nzServerSearch", "nzMaxMultipleCount", "nzMode", "nzShowSearch", "nzShowArrow", "nzTokenSeparators", "nzMaxTagCount", "compareWith", "nzOptionHeightPx", "nzOptionOverflowSize", "ngModelChange", "nzOpenChange", "nzOnSearch", "nzScrollToBottom"], ["nzDisabled", "", "nzCustomContent", ""], [3, "nzLabel", "nzValue", "nzHide", "nzDisabled"], [3, "nzLabel"], [3, "nzLabel", "nzValue", "nzDisabled", "nzHide"], ["nz-icon", "", "nzType", "loading"]],
  template: function SelectWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "sf-item-wrap", 0)(1, "nz-select", 1);
      ɵɵtwoWayListener("ngModelChange", function SelectWidget_Template_nz_select_ngModelChange_1_listener($event) {
        ɵɵtwoWayBindingSet(ctx._value, $event) || (ctx._value = $event);
        return $event;
      });
      ɵɵlistener("ngModelChange", function SelectWidget_Template_nz_select_ngModelChange_1_listener($event) {
        return ctx.change($event);
      })("nzOpenChange", function SelectWidget_Template_nz_select_nzOpenChange_1_listener($event) {
        return ctx.openChange($event);
      })("nzOnSearch", function SelectWidget_Template_nz_select_nzOnSearch_1_listener($event) {
        return ctx.onSearch($event);
      })("nzScrollToBottom", function SelectWidget_Template_nz_select_nzScrollToBottom_1_listener() {
        return ctx.scrollToBottom();
      });
      ɵɵtemplate(2, SelectWidget_Conditional_2_Template, 2, 0)(3, SelectWidget_Conditional_3_Template, 2, 0)(4, SelectWidget_Conditional_4_Template, 3, 1, "nz-option", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      ɵɵadvance();
      ɵɵproperty("nzId", ctx.id)("nzDisabled", ctx.disabled);
      ɵɵtwoWayProperty("ngModel", ctx._value);
      ɵɵproperty("nzSize", ctx.ui.size)("nzPlaceHolder", ctx.ui.placeholder)("nzNotFoundContent", ctx.ui.notFoundContent)("nzDropdownClassName", ctx.ui.dropdownClassName)("nzAllowClear", ctx.ui.allowClear)("nzDropdownStyle", ctx.ui.dropdownStyle)("nzCustomTemplate", ctx.ui.customTemplate)("nzSuffixIcon", ctx.ui.suffixIcon)("nzRemoveIcon", ctx.ui.removeIcon)("nzClearIcon", ctx.ui.clearIcon)("nzMenuItemSelectedIcon", ctx.ui.menuItemSelectedIcon)("nzMaxTagPlaceholder", ctx.ui.maxTagPlaceholder)("nzDropdownRender", ctx.ui.dropdownRender)("nzAutoClearSearchValue", ctx.i.autoClearSearchValue)("nzBorderless", ctx.i.borderless)("nzAutoFocus", ctx.i.autoFocus)("nzDropdownMatchSelectWidth", ctx.i.dropdownMatchSelectWidth)("nzServerSearch", ctx.i.serverSearch)("nzMaxMultipleCount", ctx.i.maxMultipleCount)("nzMode", ctx.i.mode)("nzShowSearch", ctx.i.showSearch)("nzShowArrow", ctx.i.showArrow)("nzTokenSeparators", ctx.i.tokenSeparators)("nzMaxTagCount", ctx.i.maxTagCount)("compareWith", ctx.i.compareWith)("nzOptionHeightPx", ctx.i.optionHeightPx)("nzOptionOverflowSize", ctx.i.optionOverflowSize);
      ɵɵadvance();
      ɵɵconditional(2, !ctx.loading && !ctx.hasGroup ? 2 : -1);
      ɵɵadvance();
      ɵɵconditional(3, !ctx.loading && ctx.hasGroup ? 3 : -1);
      ɵɵadvance();
      ɵɵconditional(4, ctx.loading ? 4 : -1);
    }
  },
  dependencies: [NgControlStatus, NgModel, NzTransitionPatchDirective, NzIconDirective, NzOptionComponent, NzSelectComponent, NzOptionGroupComponent, SFItemWrapComponent],
  encapsulation: 2
});
var SelectWidget = _SelectWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectWidget, [{
    type: Component,
    args: [{
      selector: "sf-select",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-select
      [nzId]="id"
      [nzDisabled]="disabled"
      [(ngModel)]="_value"
      (ngModelChange)="change($event)"
      [nzSize]="ui.size!"
      [nzPlaceHolder]="ui.placeholder!"
      [nzNotFoundContent]="ui.notFoundContent"
      [nzDropdownClassName]="ui.dropdownClassName!"
      [nzAllowClear]="ui.allowClear"
      [nzDropdownStyle]="ui.dropdownStyle!"
      [nzCustomTemplate]="ui.customTemplate!"
      [nzSuffixIcon]="ui.suffixIcon!"
      [nzRemoveIcon]="ui.removeIcon!"
      [nzClearIcon]="ui.clearIcon!"
      [nzMenuItemSelectedIcon]="ui.menuItemSelectedIcon!"
      [nzMaxTagPlaceholder]="ui.maxTagPlaceholder!"
      [nzDropdownRender]="ui.dropdownRender!"
      [nzAutoClearSearchValue]="i.autoClearSearchValue"
      [nzBorderless]="i.borderless"
      [nzAutoFocus]="i.autoFocus"
      [nzDropdownMatchSelectWidth]="i.dropdownMatchSelectWidth!"
      [nzServerSearch]="i.serverSearch"
      [nzMaxMultipleCount]="i.maxMultipleCount!"
      [nzMode]="i.mode!"
      [nzShowSearch]="i.showSearch"
      [nzShowArrow]="i.showArrow!"
      [nzTokenSeparators]="i.tokenSeparators!"
      [nzMaxTagCount]="i.maxTagCount!"
      [compareWith]="i.compareWith!"
      [nzOptionHeightPx]="i.optionHeightPx!"
      [nzOptionOverflowSize]="i.optionOverflowSize!"
      (nzOpenChange)="openChange($event)"
      (nzOnSearch)="onSearch($event)"
      (nzScrollToBottom)="scrollToBottom()"
    >
      @if (!loading && !hasGroup) {
        @for (o of data; track $index) {
          <nz-option [nzLabel]="o.label" [nzValue]="o.value" [nzHide]="o.hide" [nzDisabled]="o.disabled" />
        }
      }
      @if (!loading && hasGroup) {
        @for (i of data; track $index) {
          <nz-option-group [nzLabel]="i.label">
            @for (o of i.children; track $index) {
              <nz-option [nzLabel]="o.label" [nzValue]="o.value" [nzDisabled]="o.disabled" [nzHide]="o.hide" />
            }
          </nz-option-group>
        }
      }
      @if (loading) {
        <nz-option nzDisabled nzCustomContent>
          <i nz-icon nzType="loading"></i>
          {{ ui.searchLoadingText }}
        </nz-option>
      }
    </nz-select>
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _StringWidget = class _StringWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.change$ = null;
  }
  ngOnInit() {
    const {
      addOnAfter,
      addOnAfterIcon,
      addOnBefore,
      addOnBeforeIcon,
      prefix,
      prefixIcon,
      suffix,
      suffixIcon,
      autofocus
    } = this.ui;
    this.type = !!(addOnAfter || addOnBefore || addOnAfterIcon || addOnBeforeIcon || prefix || prefixIcon || suffix || suffixIcon) ? "addon" : "";
    if (autofocus === true) {
      setTimeout(() => {
        this.injector.get(ElementRef).nativeElement.querySelector(`#${this.id}`).focus();
      }, 20);
    }
    this.initChange();
  }
  reset(value) {
    if (!value && this.schema.format === "color") {
      this.setValue("#000000");
    }
  }
  initChange() {
    const dueTime = this.ui.changeDebounceTime;
    const changeFn = this.ui.change;
    if (dueTime == null || dueTime <= 0 || changeFn == null)
      return;
    this.change$ = new BehaviorSubject(this.value);
    let obs = this.change$.asObservable().pipe(debounceTime(dueTime), takeUntil(this.sfItemComp.destroy$));
    if (this.ui.changeMap != null) {
      obs = obs.pipe(switchMap(this.ui.changeMap));
    }
    obs.subscribe((val) => changeFn(val));
  }
  change(val) {
    this.setValue(val);
    if (this.change$ != null) {
      this.change$.next(val);
      return;
    }
    if (this.ui.change)
      this.ui.change(val);
  }
  focus(e) {
    if (this.ui.focus)
      this.ui.focus(e);
  }
  blur(e) {
    if (this.ui.blur)
      this.ui.blur(e);
  }
  enter(e) {
    if (this.ui.enter)
      this.ui.enter(e);
  }
};
_StringWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵStringWidget_BaseFactory;
  return function StringWidget_Factory(t) {
    return (ɵStringWidget_BaseFactory || (ɵStringWidget_BaseFactory = ɵɵgetInheritedFactory(_StringWidget)))(t || _StringWidget);
  };
})();
_StringWidget.ɵcmp = ɵɵdefineComponent({
  type: _StringWidget,
  selectors: [["sf-string"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 5,
  vars: 7,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], ["ipt", ""], [3, "nzAddOnBefore", "nzAddOnAfter", "nzAddOnBeforeIcon", "nzAddOnAfterIcon", "nzPrefix", "nzPrefixIcon", "nzSuffix", "nzSuffixIcon"], ["nz-input", "", 3, "disabled", "nzSize", "nzBorderless", "ngModel", "ngModelChange", "keyup.enter", "focus", "blur"], [3, "ngTemplateOutlet"]],
  template: function StringWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "sf-item-wrap", 0);
      ɵɵtemplate(1, StringWidget_ng_template_1_Template, 1, 11, "ng-template", null, 1, ɵɵtemplateRefExtractor)(3, StringWidget_Conditional_3_Template, 2, 9, "nz-input-group", 2)(4, StringWidget_Conditional_4_Template, 1, 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      ɵɵadvance(3);
      ɵɵconditional(3, ctx.type === "addon" ? 3 : 4);
    }
  },
  dependencies: [NgTemplateOutlet, DefaultValueAccessor, NgControlStatus, NgModel, NzTransitionPatchDirective, NzInputDirective, NzInputGroupComponent, NzInputGroupWhitSuffixOrPrefixDirective, SFItemWrapComponent],
  encapsulation: 2
});
var StringWidget = _StringWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringWidget, [{
    type: Component,
    args: [{
      selector: "sf-string",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <ng-template #ipt>
      <input
        nz-input
        [attr.id]="id"
        [disabled]="disabled"
        [attr.disabled]="disabled"
        [nzSize]="ui.size!"
        [nzBorderless]="ui.borderless"
        [ngModel]="value"
        (ngModelChange)="change($event)"
        [attr.maxLength]="schema.maxLength || null"
        [attr.type]="ui.type || 'text'"
        [attr.placeholder]="ui.placeholder"
        [attr.autocomplete]="ui.autocomplete"
        [attr.autoFocus]="ui.autofocus"
        (keyup.enter)="enter($event)"
        (focus)="focus($event)"
        (blur)="blur($event)"
      />
    </ng-template>

    @if (type === 'addon') {
      <nz-input-group
        [nzAddOnBefore]="ui.addOnBefore"
        [nzAddOnAfter]="ui.addOnAfter"
        [nzAddOnBeforeIcon]="ui.addOnBeforeIcon"
        [nzAddOnAfterIcon]="ui.addOnAfterIcon"
        [nzPrefix]="ui.prefix"
        [nzPrefixIcon]="ui.prefixIcon"
        [nzSuffix]="ui.suffix"
        [nzSuffixIcon]="ui.suffixIcon"
      >
        <ng-template [ngTemplateOutlet]="ipt" />
      </nz-input-group>
    } @else {
      <ng-template [ngTemplateOutlet]="ipt" />
    }
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _TextWidget = class _TextWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  ngOnInit() {
    this.ui._required = false;
    this.ui.html = toBool(this.ui.html, true);
  }
  reset(value) {
    this.text = value || this.ui.defaultText || "-";
  }
};
_TextWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵTextWidget_BaseFactory;
  return function TextWidget_Factory(t) {
    return (ɵTextWidget_BaseFactory || (ɵTextWidget_BaseFactory = ɵɵgetInheritedFactory(_TextWidget)))(t || _TextWidget);
  };
})();
_TextWidget.ɵcmp = ɵɵdefineComponent({
  type: _TextWidget,
  selectors: [["sf-text"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 9,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "innerHTML"], [3, "innerText"]],
  template: function TextWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "sf-item-wrap", 0);
      ɵɵtemplate(1, TextWidget_Conditional_1_Template, 1, 1, "span", 1)(2, TextWidget_Conditional_2_Template, 1, 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("sf__text-html", ctx.ui.html);
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      ɵɵadvance();
      ɵɵconditional(1, ctx.ui.html ? 1 : 2);
    }
  },
  dependencies: [SFItemWrapComponent],
  encapsulation: 2
});
var TextWidget = _TextWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextWidget, [{
    type: Component,
    args: [{
      selector: "sf-text",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
    [class.sf__text-html]="ui.html"
  >
    @if (ui.html) {
      <span [innerHTML]="text"></span>
    } @else {
      <span [innerText]="text"></span>
    }
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var _TextareaWidget = class _TextareaWidget extends ControlUIWidget {
  constructor() {
    super(...arguments);
    this.autosize = true;
  }
  ngOnInit() {
    if (this.ui.autosize != null) {
      this.autosize = this.ui.autosize;
    }
    if (this.ui.computeCharacterCount == null) {
      this.ui.computeCharacterCount = (v) => v.length;
    }
  }
  change(val) {
    this.setValue(val);
    if (this.ui.change)
      this.ui.change(val);
  }
  focus(e) {
    if (this.ui.focus)
      this.ui.focus(e);
  }
  blur(e) {
    if (this.ui.blur)
      this.ui.blur(e);
  }
};
_TextareaWidget.ɵfac = /* @__PURE__ */ (() => {
  let ɵTextareaWidget_BaseFactory;
  return function TextareaWidget_Factory(t) {
    return (ɵTextareaWidget_BaseFactory || (ɵTextareaWidget_BaseFactory = ɵɵgetInheritedFactory(_TextareaWidget)))(t || _TextareaWidget);
  };
})();
_TextareaWidget.ɵcmp = ɵɵdefineComponent({
  type: _TextareaWidget,
  selectors: [["sf-textarea"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 5,
  vars: 7,
  consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], ["ipt", ""], [3, "nzMaxCharacterCount", "nzComputeCharacterCount"], ["nz-input", "", 3, "disabled", "nzSize", "ngModel", "nzAutosize", "nzBorderless", "ngModelChange", "focus", "blur"], [3, "ngTemplateOutlet"]],
  template: function TextareaWidget_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "sf-item-wrap", 0);
      ɵɵtemplate(1, TextareaWidget_ng_template_1_Template, 2, 9, "ng-template", null, 1, ɵɵtemplateRefExtractor)(3, TextareaWidget_Conditional_3_Template, 3, 11, "nz-textarea-count", 2)(4, TextareaWidget_Conditional_4_Template, 1, 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
      ɵɵadvance(3);
      ɵɵconditional(3, ctx.ui.maxCharacterCount ? 3 : 4);
    }
  },
  dependencies: [NgTemplateOutlet, DefaultValueAccessor, NgControlStatus, NgModel, NzTextareaCountComponent, NzInputDirective, NzAutosizeDirective, SFItemWrapComponent],
  encapsulation: 2
});
var TextareaWidget = _TextareaWidget;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextareaWidget, [{
    type: Component,
    args: [{
      selector: "sf-textarea",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <ng-template #ipt>
      <textarea
        nz-input
        [attr.id]="id"
        [disabled]="disabled"
        [attr.disabled]="disabled"
        [nzSize]="ui.size!"
        [ngModel]="value"
        (ngModelChange)="change($event)"
        [attr.maxLength]="schema.maxLength || null"
        [attr.placeholder]="ui.placeholder"
        [nzAutosize]="autosize"
        [nzBorderless]="ui.borderless"
        (focus)="focus($event)"
        (blur)="blur($event)"
      >
      </textarea>
    </ng-template>

    @if (ui.maxCharacterCount) {
      <nz-textarea-count
        [nzMaxCharacterCount]="ui.maxCharacterCount"
        [nzComputeCharacterCount]="ui.computeCharacterCount!"
      >
        <textarea
          nz-input
          [attr.id]="id"
          [disabled]="disabled"
          [attr.disabled]="disabled"
          [nzSize]="ui.size!"
          [ngModel]="value"
          (ngModelChange)="change($event)"
          [attr.maxLength]="schema.maxLength || null"
          [attr.placeholder]="ui.placeholder"
          [nzAutosize]="autosize"
          [nzBorderless]="ui.borderless"
          (focus)="focus($event)"
          (blur)="blur($event)"
        >
        </textarea>
      </nz-textarea-count>
    } @else {
      <ng-template [ngTemplateOutlet]="ipt" />
    }
  </sf-item-wrap>`,
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation$1.None
    }]
  }], null, null);
})();
var NzWidgetRegistry = class extends WidgetRegistry {
  constructor() {
    super();
    this.register("object", ObjectWidget);
    this.register("array", ArrayWidget);
    this.register("text", TextWidget);
    this.register("string", StringWidget);
    this.register("number", NumberWidget);
    this.register("integer", NumberWidget);
    this.register("date", DateWidget);
    this.register("radio", RadioWidget);
    this.register("checkbox", CheckboxWidget);
    this.register("boolean", BooleanWidget);
    this.register("textarea", TextareaWidget);
    this.register("select", SelectWidget);
    this.register("custom", CustomWidget);
    this.setDefault(StringWidget);
  }
};
var ZORROS = [NzButtonModule, NzCardModule, NzCheckboxModule, NzDatePickerModule, NzFormModule, NzGridModule, NzIconModule, NzInputModule, NzInputNumberModule, NzModalModule, NzRadioModule, NzSelectModule, NzSwitchModule, NzToolTipModule];
var COMPONENTS = [SFComponent, SFItemComponent, SFItemWrapComponent, SFTemplateDirective, SFFixedDirective];
var WIDGETS = [ObjectWidget, ArrayWidget, StringWidget, NumberWidget, DateWidget, RadioWidget, CheckboxWidget, BooleanWidget, TextareaWidget, SelectWidget, CustomWidget, TextWidget];
var _DelonFormModule = class _DelonFormModule {
  static forRoot() {
    return {
      ngModule: _DelonFormModule,
      providers: [{
        provide: SchemaValidatorFactory,
        useClass: AjvSchemaValidatorFactory,
        deps: [AlainConfigService, NgZone]
      }, {
        provide: WidgetRegistry,
        useClass: NzWidgetRegistry
      }]
    };
  }
};
_DelonFormModule.ɵfac = function DelonFormModule_Factory(t) {
  return new (t || _DelonFormModule)();
};
_DelonFormModule.ɵmod = ɵɵdefineNgModule({
  type: _DelonFormModule,
  declarations: [SFComponent, SFItemComponent, SFItemWrapComponent, SFTemplateDirective, SFFixedDirective, ObjectWidget, ArrayWidget, StringWidget, NumberWidget, DateWidget, RadioWidget, CheckboxWidget, BooleanWidget, TextareaWidget, SelectWidget, CustomWidget, TextWidget],
  imports: [CommonModule, FormsModule, DelonLocaleModule, NzButtonModule, NzCardModule, NzCheckboxModule, NzDatePickerModule, NzFormModule, NzGridModule, NzIconModule, NzInputModule, NzInputNumberModule, NzModalModule, NzRadioModule, NzSelectModule, NzSwitchModule, NzToolTipModule],
  exports: [SFComponent, SFItemComponent, SFItemWrapComponent, SFTemplateDirective, SFFixedDirective]
});
_DelonFormModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, DelonLocaleModule, ZORROS]
});
var DelonFormModule = _DelonFormModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DelonFormModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, DelonLocaleModule, ...ZORROS],
      declarations: [...COMPONENTS, ...WIDGETS],
      exports: COMPONENTS
    }]
  }], null, null);
})();
var ERRORSDEFAULT = {
  "false schema": `布尔模式出错`,
  $ref: `无法找到引用{ref}`,
  additionalItems: `不允许超过{ref}`,
  additionalProperties: `不允许有额外的属性`,
  anyOf: `数据应为 anyOf 所指定的其中一个`,
  dependencies: `应当拥有属性{property}的依赖属性{deps}`,
  enum: `应当是预设定的枚举值之一`,
  format: `格式不正确`,
  // `应当匹配格式 "{format}"`,
  type: `类型应当是 {type}`,
  required: `必填项`,
  maxLength: `至多 {limit} 个字符`,
  minLength: `至少 {limit} 个字符以上`,
  minimum: `必须 {comparison}{limit}`,
  formatMinimum: `必须 {comparison}{limit}`,
  maximum: `必须 {comparison}{limit}`,
  formatMaximum: `必须 {comparison}{limit}`,
  maxItems: `不应多于 {limit} 个项`,
  minItems: `不应少于 {limit} 个项`,
  maxProperties: `不应多于 {limit} 个属性`,
  minProperties: `不应少于 {limit} 个属性`,
  multipleOf: `应当是 {multipleOf} 的整数倍`,
  not: `不应当匹配 "not" schema`,
  oneOf: `只能匹配一个 "oneOf" 中的 schema`,
  pattern: `数据格式不正确`,
  uniqueItems: `不应当含有重复项 (第 {j} 项与第 {i} 项是重复的)`,
  custom: `格式不正确`,
  propertyNames: `属性名 "{propertyName}" 无效`,
  patternRequired: `应当有属性匹配模式 {missingPattern}`,
  switch: `由于 {caseIndex} 失败，未通过 "switch" 校验`,
  const: `应当等于常量`,
  contains: `应当包含一个有效项`,
  formatExclusiveMaximum: `formatExclusiveMaximum 应当是布尔值`,
  formatExclusiveMinimum: `formatExclusiveMinimum 应当是布尔值`,
  if: `应当匹配模式 "{failingKeyword}"`
};
function provideSFConfig(options) {
  const provides = [{
    provide: SchemaValidatorFactory,
    useClass: AjvSchemaValidatorFactory,
    deps: [AlainConfigService, NgZone]
  }, {
    provide: WidgetRegistry,
    useClass: NzWidgetRegistry
  }];
  if (options?.widgets) {
    provides.push({
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useValue: () => {
        const srv = inject(WidgetRegistry);
        options?.widgets?.forEach((widget) => srv.register(widget.KEY, widget.type));
      }
    });
  }
  return makeEnvironmentProviders(provides);
}
export {
  AjvSchemaValidatorFactory,
  ArrayLayoutWidget,
  ArrayProperty,
  ArrayWidget,
  AtomicProperty,
  BooleanProperty,
  BooleanWidget,
  CheckboxWidget,
  ControlUIWidget,
  ControlWidget,
  CustomWidget,
  DateWidget,
  DelonFormModule,
  ERRORSDEFAULT,
  FormProperty,
  FormPropertyFactory,
  NumberProperty,
  NumberWidget,
  NzWidgetRegistry,
  ObjectLayoutWidget,
  ObjectProperty,
  ObjectWidget,
  PropertyGroup,
  RadioWidget,
  SFComponent,
  SFFixedDirective,
  SFItemComponent,
  SFItemWrapComponent,
  SFTemplateDirective,
  SF_DEFAULT_CONFIG,
  SchemaValidatorFactory,
  SelectWidget,
  StringProperty,
  StringWidget,
  TextWidget,
  TextareaWidget,
  Widget,
  WidgetFactory,
  WidgetRegistry,
  di,
  getCopyEnum,
  getData,
  getEnum,
  isBlank,
  isDateFns,
  mergeConfig,
  orderProperties,
  provideSFConfig,
  resolveIfSchema,
  retrieveSchema,
  toBool,
  useFactory
};
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)
*/
//# sourceMappingURL=@delon_form.js.map
